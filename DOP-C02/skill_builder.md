# Developer Learning Plan
## Amazon API Gateway for Serverless Applications
- API Gateway
  - API 관리의 어려움
    - API를 사용하면 많은 이점이 있지만 API를 관리하는 동안 자주 발생하는 문제에 직면할 수도 있습니다.
      - 서버리스 애플리케이션에서 API 호출 처리
      - 여러 API 버전 및 환경으로 작업
      - 액세스 및 권한 부여 제어
      - 트래픽 스파이크 관리
      - 서드 파티 액세스 모니터링
  - API Gateway의 개발자 기능
    - 여러 버전의 API를 동시에 실행
      - API Gateway를 사용하면 같은 API의 여러 버전을 동시에 실행할 수 있으므로 신속하게 새 버전을 반복, 테스트 및 릴리스할 수 있습니다.
      - API를 변경하고 다양한 사용자를 위해 여러 API 버전을 호스팅할 수도 있습니다.
    - 빠른 SDK 생성
      - REST API를 사용하는 경우 API Gateway에서는 다양한 플랫폼을 위한 클라이언트 소프트웨어 개발 키트(SDK)를 생성할 수 있으며, 생성한 SDK를 이용하여 애플리케이션에서 새로운 API를 빠르게 테스트하고 서드 파티 개발자에게 해당 SDK를 배포할 수 있습니다.
      - 생성된 SDK는 AWS 자격 증명을 사용하여 API 키 및 서명 요청을 처리합니다. API Gateway는 Java, JavaScript, Android용 Java, iOS용 Objective-C 또는 Swift, Ruby용 클라이언트 SDK를 생성할 수 있습니다
    - 요청/응답 데이터 변환 또는 검증
      - API Gateway를 사용하면 또한 수신 및 발신 요청을 모두 변환하고 유효성을 검사할 수도 있습니다.
  - API 액세스 관리 기능
    - 지연 시간 단축 및 트래픽 조절
      - API Gateway는 엣지 로케이션의 Amazon CloudFront 글로벌 네트워크를 활용하여 최종 사용자에게 API 요청 및 응답에 대해 최소 지연 시간을 제공합니다.
      - 이 서비스를 통해 트래픽을 조절하고 API 호출 권한을 부여하여 백엔드 작업이 트래픽 스파이크에 대처하고 백엔드 시스템이 불필요하게 호출되지 않도록 할 수도 있습니다.
    - 기본 제공되는 유연한 권한 부여 옵션
      - API Gateway는 몇 가지 권한 부여 옵션을 제공합니다. AWS Identity and Access Management(IAM)와 Amazon Cognito를 사용하여 API에 대한 액세스 권한을 부여할 수 있습니다.
      - OAuth 토큰을 사용하는 경우 API Gateway가 기본 OpenID Connect(OIDC) 및 OAuth2 지원도 제공합니다.
      - 사용자 지정 권한 부여 요구 사항을 지원하기 위해 Lambda에서 Lambda 권한 부여자를 호출할 수 있습니다. Lambda 권한 부여자를 사용하면 사용자 지정 Lambda 함수를 사용하여 고유한 권한 부여 코드를 개발할 수 있습니다.
    - 서드 파티 개발자를 위한 API 키
      - REST API를 사용하는 경우 API Gateway는 API에 액세스하는 서드 파티 개발자 에코시스템을 관리할 수 있도록 지원합니다.
      - API Gateway에서 API 키를 생성하고, API 키별로 세부적인 액세스 권한을 설정하고, 서드 파티 개발자가 API에 액세스할 수 있도록 해당 키를 서드 파티 개발자에게 배포할 수 있습니다.
      - API 키는 API에 대한 기본 권한 부여 메커니즘은 아니지만 특정 사용자 또는 서비스의 사용량을 추적할 수 있는 기능을 제공합니다.
  - 사용 사례에 가장 적합한 API 유형 선택
    - REST API
      - 요금에 API 구축, 관리 및 게시에 필요한 모든 기능이 포함된 세트
      - 백엔드 인증, AWS WAF 또는 리소스 정책에 인증서를 사용하는 API 구축
      - 엣지 최적화 또는 프라이빗 API 유형이 필요한 워크로드
      - REST는 Representational State Transfer의 약자입니다. REST는 클라이언트가 서버 데이터에 액세스하는 데 사용할 수 있는 GET, PUT, DELETE와 같은 함수 집합을 정의합니다. 클라이언트와 서버는 HTTP를 사용하여 데이터를 교환합니다.
      - REST API의 주된 특징은 스테이스리스라는 점입니다. 스테이트리스는 서버가 요청 간에 클라이언트 데이터를 저장하지 않음을 의미합니다.
      - REST API는 단일 솔루션에서 API 프록시 기능 및 관리 기능을 제공합니다. 또한 REST API는 사용 플랜, API 키, 게시, API 수익 창출 같은 API 관리 기능도 제공합니다.
    - HTTP API
      - 네이티브 OIDC 및 OAuth 2 권한 부여 기능이 탑재된 최신 API 구축
      - Lambda 또는 모든 HTTP 엔드포인트를 위한 프록시 API 구축
      - 지연 시간에 민감한 워크로드용 API
      - Hypertext Transfer Protocol(HTTP) API를 사용하여 REST API보다 지연 시간이 짧고 비용이 저렴한 RESTful API를 만들 수 있습니다.
      - HTTP API를 사용하여 Lambda 함수 또는 라우팅 가능한 HTTP 엔드포인트로 요청을 보낼 수 있습니다.
      - HTTP API는 Lambda 함수 또는 HTTP 백엔드에 프록시 역할을 하는 API를 구축하는 데 최적화되어 서버리스 워크로드에 적합합니다. API 관리 기능은 현재 제공하지 않습니다.
    - WEBSOCKET API
      - 클라이언트와 서비스가 독립적으로 서로 메시지를 보낼 수 있는 양방향 통신
      - 클라이언트가 명시적으로 요청하지 않아도 서비스가 데이터를 클라이언트로 푸시할 수 있어 더 풍부한 클라이언트/서비스 상호 작용
      - 실시간 통신용 API
      - WebSocket API는 클라이언트가 WebSocket 프로토콜을 통해 액세스할 수 있는 API를 제공합니다.
      - REST 및 HTTP API와 달리 WebSocket API는 양방향 통신을 허용합니다.
      - WebSocket API는 채팅 애플리케이션, 협업 플랫폼, 멀티플레이어 게임 및 금융 거래 플랫폼 같은 실시간 애플리케이션에서 자주 사용합니다.
      - WebSocket API는 연결된 클라이언트 간에 영구 연결을 유지하여 실시간 메시징 통신을 가능하게 합니다.
      - API Gateway에서 WebSocket API를 사용하면 연결된 클라이언트의 메시지가 수신될 때 호출할 Lambda 함수, Amazon Kinesis 또는 HTTP 엔드포인트와의 백엔드 통합을 정의할 수 있습니다.
- WebSocket API 설계
  - WebSocket API는 다음과 같은 실시간 애플리케이션에서 자주 사용합니다.
    - 채팅 애플리케이션
    - 스트리밍 대시보드
    - 실시간 경고 및 알림
    - 협업 플랫폼
    - 멀티플레이어 게임
    - 금융 거래 플랫폼
- REST API 설계
  - API Gateway REST API 엔드포인트 유형
    - 리전 엔드포인트
      - 리전 엔드포인트는 API와 동일한 AWS 리전에서 호출할 때 지연 시간을 줄일 수 있도록 설계되었습니다. 이 모델에서는 API Gateway가 API 앞에 자체 CloudFront 배포를 배포하지 않습니다. 대신에 API로 전송되는 트래픽은 배포한 리전의 API 엔드포인트로 직접 전달됩니다.
      - 이 엔드포인트 유형을 사용하면 동일한 리전 내에서 API(예: 동일한 리전 내의 EC2 인스턴스에서 액세스할 API)를 호출하는 애플리케이션의 지연 시간이 단축됩니다.
      - 리전 엔드포인트는 API Gateway 앞에 사용의 CloudFront 배포 또는 콘텐츠 전송 네트워크(CDN)를 배포하고 사용자 지정 시나리오에 대한 자체 설정을 사용하여 이 배포를 제어하도록 유연성을 제공합니다
    - 엣지 최적화 엔드포인트
      - 엣지 최적화 엔드포인트는 인터넷 어디에서든 클라이언트 지연 시간을 줄일 수 있도록 설계되었습니다. 엣지 최적화 엔드포인트를 선택하는 경우 API Gateway는 API에 대한 액세스 지연 시간을 줄일 수 있는 완전관리형 CloudFront 배포를 자동으로 구성합니다.
      - 이 엔드포인트 유형 설정은 API의 최초 적중 지연 시간을 줄입니다. 관리형 CloudFront 배포를 사용하면 CDN에 대한 비용을 지불하거나 API Gateway에서 별도로 CDN을 관리할 필요성이 없다는 이점도 있습니다.
    - 프라이빗 엔드포인트
      - 프라이빗 엔드포인트는 선택한 Amazon Virtual Private Cloud(Amazon VPC) 내부에서만 API를 노출하도록 설계되었습니다. 이 엔드포인트 유형은 계속 API Gateway가 관리하지만 요청은 사용자가 제어하는 단일 Virtual Private Cloud(VPC) 내에서만 라우팅 및 시작할 수 있습니다.
      - 이 엔드포인트 유형은 인터넷에서 공개적으로 노출할 수 없는 의료 데이터나 금융 데이터와 같이 고도의 보안을 요하는 워크로드가 있는 애플리케이션용으로 설계되었습니다. 프라이빗 API의 데이터 송신 요금은 없습니다.
  - API Gateway 선택적 캐시
    - Amazon API Gateway에서 API 캐싱을 설정하여 엔드포인트의 응답을 캐시할 수 있습니다. 캐싱을 사용하면 엔드포인트에 대한 호출 수를 줄이고 API에 대한 요청 지연 시간을 개선할 수 있습니다.
    - API Gateway 캐싱을 사용하는 이유
      - 캐싱이 설정된 경우 API Gateway는 지정된 유지 시간(TTL) 동안 엔드포인트의 응답을 캐시합니다. 그런 다음 API Gateway는 엔드포인트에 요청하는 대신 캐시에서 엔드포인트 응답을 조회하여 요청에 응답합니다.
      - 캐시를 사용하면 2가지 큰 이점이 있습니다.
        - 요청을 처리하는 데 필요한 전체 지연 시간을 줄입니다.
        - 백엔드에 수행해야 하는 요청 수를 최소화합니다.
      - 이 기능은 규모를 변경하여 백엔드 리소스에 대한 호출의 양을 줄이는 경우에 훨씬 더 가치가 있습니다.
    - API 스테이지당 캐싱 구성
      - 캐시를 0.5~237GB 크기로 프로비저닝
        - 캐싱을 설정하면 캐시 크기를 0.5~237GB로 구성할 수 있습니다. 각 캐시 항목에 대해 최대 TTL을 구성 및 사용자 지정할 수도 있습니다.
      - TTL(초) 설정
        - API 캐싱의 기본 TTL 값은 300초입니다. 최대 TTL 값은 3,600초입니다. TTL을 0으로 설정하면 API Gateway에서 캐싱이 해제됩니다.
      - 캐시 데이터 암호화를 설정
        - 필요한 경우 캐시된 데이터를 암호화할 수도 있습니다.
      - GET 메서드만 캐시됨
        - 스테이지의 캐시 설정에서 캐싱을 설정하면 GET 메서드만 캐시됩니다. 매우 명백한 이유가 없는 한 기타 유형의 호출은 캐시하지 않는 것이 좋습니다.
      - 메서드별 구성
        - 개별 메서드에 대해 스테이지 수준 설정을 재정의할 수 있습니다. 특정 메서드의 캐싱을 설정 또는 해제하거나, TTL을 늘리거나 줄이거나, 캐시된 응답에 대해 암호화를 설정하거나 해제할 수 있습니다.
  - 메서드 호출 결과
    - Request(요청): 요청은 메서드에 대해 호출된 리소스의 경로입니다.
    - Status(상태): 상태는 응답의 HTTP 상태 코드입니다.
    - Latency(지연 시간): 지연 시간은 호출자로부터 요청을 수신한 시간과 응답 반환 시간의 시간차입니다.
    - Response Body(응답 본문): 응답 본문은 HTTP 응답 본문입니다.
    - Response Headers(응답 헤더): 응답 헤더는 HTTP 응답 헤더입니다.
  - 리소스 정책 및 인증 방법
    - 리소스 정책과 인증 메서드가 함께 작동하여 API에 대한 액세스 권한을 부여합니다. API 보안을 확보하는 메서드가 함께 작동합니다.
    - API Gateway 리소스 정책만
      - 호출자의 인바운드 기준에 명시적 허용이 필요합니다. 찾을 수 없는 경우에는 호출자가 거부됩니다.
    - Lambda 권한 부여자 및 리소스 정책
      - 정책에 명시적 거부가 있는 경우에는 호출자는 즉시 액세스가 거부됩니다.
      - 그렇지 않은 경우에는 Lambda 권한 부여자가 호출되면서 리소스 정책으로 평가되는 정책 문서를 반환합니다.
    - IAM 인증 및 리소스 정책
      - 사용자가 IAM으로 성공적으로 인증되는 경우에는 해당 IAM 사용자에게 연결된 정책과 리소스 정책이 함께 평가됩니다.
      - 호출자와 API 소유자가 별도의 계정에 있는 경우 IAM 사용자 정책과 리소스 정책 모두 명시적으로 허용하면 호출자가 진행합니다.
      - 호출자와 API 소유자가 동일한 계정에 있는 경우 사용자 정책 또는 리소스 정책이 명시적으로 허용해야 호출자가 진행합니다.
    - Cognito 인증 및 리소스 정책
      - API Gateway가 Cognito를 통해 호출자를 인증하는 경우 리소스 정책이 독립적으로 평가됩니다.
      - 명시적 허용이 있는 경우 호출자가 진행합니다.
      - 명시적 거부가 있거나 허용 및 거부 모두 없으면 거부됩니다.
  - API Gateway에 대한 CloudWatch 지표
    - Count: 특정 기간의 총 API 요청 수
    - Latency: API Gateway가 요청을 클라이언트에서 수신한 시간부터 클라이언트에게 응답을 반환하는 시간까지 걸린 시간(단위: 밀리초). 여기에는 통합 지연 시간과 기타 API Gateway 오버헤드가 포함됩니다.
    - IntegrationLatency: API Gateway가 요청을 백엔드로 릴레이하는 때부터 백엔드에서 응답을 수신할 때까지 걸리는 시간
    - 4xxError: 지정된 기간에 캡처된 클라이언트 측 오류
    - 5xxError: 지정된 기간에 캡처된 서버 측 오류
    - CacheHitCount: 지정된 기간에 API 캐시에서 제공된 요청 수
    - CacheMissCount: API 캐싱이 설정되어 있을 때 지정된 기간 동안 백엔드에서 제공된 요청 수
    - 이러한 지표를 사용하여 다음과 같은 세부 정보를 모니터링할 수 있습니다.
      - API가 호출되는 빈도
      - API의 호출 수
      - API 응답의 지연 시간
      - 오류가 발생했는지 여부 및 오류가 발생한 경우 400 오류인지, 500 오류인지 여부
      - 캐시에 적중하는지 여부 또는 캐싱이 활성화된 동안 백엔드를 호출해야 한 횟수
  - X-Ray 및 CloudTrail로 모니터링
    - AWS X-Ray
      - X-Ray를 사용하여 Amazon API Gateway API를 통해 기본 서비스로 이동하는 사용자 요청을 추적하고 분석할 수 있습니다.
      - X-Ray를 사용하면 애플리케이션이 성능 문제 및 오류의 근본 원인 식별과 문제 해결을 올바로 수행하는지 파악할 수 있습니다.
      - X-Ray는 사용자의 API와 백엔드 서비스에서 지연 시간 및 오류를 분석할 수 있도록 전체 요청에 대한 엔드 투 엔드 뷰를 제공합니다.
      - 샘플링 규칙을 구성하여 지정한 기준에 따라 어떤 요청을 어떤 샘플링 속도로 기록할지를 X-Ray에 지정할 수도 있습니다.
        - API 및 해당 백엔드 서비스의 지연 시간과 디버그 오류를 분석합니다.
        - 특정 요청에 집중하도록 샘플링 규칙을 구성합니다.
    - AWS CloudTrail
      - CloudTrail은 API Gateway에 대한 모든 API 호출을 이벤트로 캡처합니다.
        - IP 주소, 요청자 및 요청 시간이 포함됩니다.
        - 이벤트 기록을 볼 수 있습니다.
        - 이벤트를 Amazon Simple Storage Service(Amazon S3) 버킷으로 전송하는 추적을 생성합니다.

## Amazon DynamoDB for Serverless Architectures
- Amazon DynamoDB
  - DynamoDB는 온라인 트랜잭션 처리(OLTP) 워크로드용으로 설계된 서버리스, 완전관리형NoSQL(비관계형) 데이터베이스 서비스입니다.
  - 유연한 스키마
  - JSON 문서 또는 키-값 데이터 구조
  - 이벤트 중심 프로그래밍 지원
  - AWS Management Console, CLI 및 SDK를 통해 액세스
  - 가용성, 내구성 및 확장성 기본 제공
  - 수평 확장
  - 세분화된 액세스 제어 제공
  - 다른 AWS 서비스와 통합
- 테이블 및 파티션
  - Amazon DynamoDB에서는 데이터가 테이블에 저장됩니다. 테이블에는 속성이 있는 항목이 포함되어 있습니다. 항목은 관계형 데이터베이스의 행 또는 튜플로, 속성은 열로 간주할 수 있습니다.
- 모형
  - 키-값 모형
    - DynamoDB는 속성에 대해 숫자, 문자열, 이진(base64 인코딩), 부울 및 Null 데이터 유형을 지원합니다.
    - 숫자, 문자열 및 이진의 집합을 사용할 수도 있습니다. 집합의 항목은 모두 동일한 유형이어야 하며 고유해야 합니다. 집합은 순서를 유지하지 않습니다.
  - JSON 문서 모형
    - 애플리케이션이 JSON 문서로 작동하는 경향이 있는 경우 JSON 문서를 개별 속성으로 추가하거나 테이블의 각 항목이 JSON 문서인 모형을 사용할 수 있습니다.
    - 이 모형은 Map(중첩된 속성 - 혼합 유형의 정렬되지 않은 항목) 및 List(JSON 배열과 유사, 모든 데이터 유형의 값의 정렬된 목록)를 사용합니다. 이러한 문서 데이터 유형은 최대 32수준의 깊이까지 중첩될 수 있습니다.
- 기본 항목 요청
  - 쓰기
    - PutItem - 지정된 기본 키에 항목을 씁니다.
    - UpdateItem - 지정된 기본 키를 사용하여 항목의 속성을 변경합니다.
    - BatchWriteItem - 지정된 기본 키에 항목 묶음을 씁니다.
    - deleteItem - 지정된 기본 키와 연결된 항목을 제거합니다.
  - 읽기
    - GetItem - 지정된 기본 키와 연결된 항목을 검색합니다.
    - BatchGetItem - 지정된 기본 키의 이 묶음으로 항목을 검색합니다.
    - Query - 지정된 파티션 키의 경우 정렬 키 표현식(정순/역순)과 일치하는 항목을 검색합니다.
    - Scan - 테이블에 있는 모든 항목을 제공합니다.
- 보조 인덱스
  - 테이블의 기본 키에 속하지 않은 속성에 대해 쿼리를 수행하려면 보조 인덱스를 생성하면 됩니다. 로컬과 글로벌의 두 가지 유형이 있습니다. 테이블당 최대 5개의 글로벌 보조 인덱스와 5개의 로컬 보조 인덱스를 정의할 수 있습니다.
  - 로컬 보조 인덱스
    - 인덱스는 파티션 키에 대해 로컬입니다.
    - 동일한 파티션 키를 사용하여 항목을 쿼리할 수 있습니다(쿼리와 함께 지정) 테이블에서 특정 파티션 키가 있는 모든 항목과 이에 상응하는 로컬 보조 인덱스의 항목(이 둘을 항목 모음이라고 통칭함)이 같은 파티션에 저장됩니다. 항목 모음의 총 크기는 10GB를 초과할 수 없습니다.
    - 파티션 키는 테이블의 파티션 키와 같습니다. 정렬 키는 어떤 스칼라 속성도 될 수 있습니다.
    - 테이블이 생성될 때만 생성할 수 있으며 삭제할 수 없습니다.
    - 최종 일관성과 강력한 일관성을 지원합니다.
    - 자체 프로비저닝된 처리량이 없습니다.
    - 쿼리는 인덱스에 프로젝션되지 않은 속성을 반환할 수 있습니다.
  - 글로벌 보조 인덱스
    - 인덱스는 모든 파티션 키에 있습니다.
    - 모든 파티션에서 전체 테이블을 쿼리할 수 있습니다.
    - 원래 테이블의 파티션 키 및 정렬 키와 다른 파티션 키와 정렬 키(선택 사항)가 있을 수 있습니다.
    - 키 값이 고유할 필요는 없습니다.
    - 테이블이 생성될 때 생성하거나 기존 테이블에 추가할 수 있고 삭제할 수 있습니다.
    - 최종 일관성만 지원합니다.
    - 읽기 및 쓰기 작업에 대한 자체 프로비저닝된 처리량 설정이 있습니다.
    - 쿼리는 인덱스로 프로젝션되는 속성만 반환합니다.
- DynamoDB 스트림
  - DynamoDB 스트림은 테이블에 대한 변경 사항 정보를 시간순으로 표시합니다. 스트림의 레코드는 변경 사항이 발생한 순서를 그대로 유지합니다. 각 변경 사항은 정확히 하나의 스트림 레코드를 포함합니다. 스트림 레코드는 24시간 동안 사용할 수 있습니다.
- 기존 데이터를 DynamoDB로 마이그레이션하기 위한 옵션
  - 실시간 마이그레이션
    - DynamoDB 테이블을 생성합니다.
    - 소스 및 DynamoDB 모두에 쓰기 위해 애플리케이션을 수정합니다.
    - 백필(back-fill)을 수행합니다.
    - 검증합니다.
    - DynamoDB에서 읽을 애플리케이션을 수정합니다.
    - DynamoDB에만 쓰도록 애플리케이션을 수정합니다.
    - 낙후된 데이터 스토어를 종료합니다.
    - 백필과 같은 데이터 내보내기, 변환 및 가져오기의 경우 고려할 수 있으며 많이 사용되는 다양한 옵션이 있습니다. 즉, DynamoDB 커넥터를 사용하는 Hive가 포함된 AWS Data Pipeline, AWS Glue, Amazon EMR이 있습니다.
  - AWS Data Migration Service(DMS)
    - DMS는 소스인 Cassandra, MongoDB 및 다수의 관계형 데이터베이스에서 DynamoDB로 데이터를 이동할 수 있는 서비스입니다.
    - DMS를 사용하여 전체 데이터 집합의 초기 복사본을 생성한 다음 계속해서 DynamoDB 테이블을 업데이트할 수 있습니다.
    - 애플리케이션에서 전환할 준비가 되었다면 SDK를 사용하여 DynamoDB에 연결하는 새 버전의 소프트웨어를 배포합니다.
    - DynamoDB 서비스에 더 잘 맞게 데이터를 다시 모형화할 수 있습니다. 특히 관계형 데이터베이스에서 마이그레이션하는 경우에 말입니다.

## Advanced Testing Practices Using AWS DevOps Tools
- 모듈 1: 테스트 개요
  - 이점
    - 개발자 생산성 향상
      - 자동화된 테스트를 통해 개발자는 수동 태스크에서 벗어날 수 있으므로 팀의 생산성을 높일 수 있습니다. 고객에게 공개되는 오류 및 버그의 수를 줄이는 데 도움이 되는 행동을 장려합니다.
    - 버그를 신속하게 찾아서 해결
      - 개발 프로세스에서 테스트를 조기에 구현하면 개발자가 버그를 더 빨리 발견할 수 있습니다. 문제를 더 빨리 발견하면 애플리케이션 내에서 문제가 더 심각해지기 전에 해결할 수 있습니다. 자동화와 결합하면 각 빌드가 애플리케이션의 유효성을 검증합니다.
    - 보다 신속하게 업데이트 제공
      - 수동 프로세스에는 시간이 걸립니다. 소요되는 시간은 테스터의 가용성과 승인 프로세스에 필요한 시간에 따라 결정됩니다. 파이프라인의 수동 프로세스 수를 줄이면 개발 파이프라인의 속도를 높여 업데이트를 보다 빠르게 제공할 수 있습니다.
    - 소프트웨어 릴리스 프로세스 자동화
      - 코드 파이프라인을 자동화하면 팀에서 프로덕션에 릴리스할 코드 변경 사항을 자동으로 빌드, 테스트, 준비할 수 있습니다. 이를 통해 신속하고 효율적인 소프트웨어 제공이 가능합니다. 또한 소프트웨어 릴리스 프로세스에서 병목 현상을 일으키지 않으면서 고객에게 혁신을 더 빠르게 제공할 수 있습니다.
  - 관련된 테스트 단계
    - 단위 테스트
      - 단위 테스트는 범위가 작으며 일반적으로 애플리케이션의 매우 구체적인 부분을 테스트합니다.
      - 단위 테스트는 애플리케이션 코드의 개별 단위를 테스트하므로 빠르게 문제를 식별하고 격리하는 데 유용합니다.
      - 자동화된 지속적 통합/지속적 전달/지속적 배포(CI/CD) 프로세스의 일부로 불량 코드가 프로덕션 환경에 배포되는 것을 방지하는 데도 사용할 수 있습니다.
      - 이 테스트는 개발자가 워크스테이션이나 로컬 개발 환경에서 신속하게 실행할 수 있도록 범위가 충분히 작아야 합니다. 개발자는 즉각적인 피드백을 받고 필요한 경우 애플리케이션의 코드를 수정합니다.
    - 서비스, 통합 및 구성 요소 테스트
      - 통합 테스트(서비스 또는 구성 요소 테스트라고도 함)는 애플리케이션의 구성 요소가 애플리케이션 및 서드 파티 구성 요소의 다른 부분과 성공적으로 통신하고 상호 작용할 수 있는지 확인합니다.
      - 예를 들어 통합 테스트는 애플리케이션의 데이터베이스 연결 또는 서드 파티 웹 서비스를 호출하는 기능을 테스트할 수 있습니다.
    - 성능 및 규정 준수 테스트
      - 보안 테스트는 애플리케이션의 코드가 보안 표준 및 필수 사양을 준수하는지를 결정합니다.
      - 예를 들어 Amazon Simple Storage Service(Amazon S3) 버킷에 객체를 업로드할 때 서버 측 암호화 사용을 테스트할 수 있습니다.
      - 성능 테스트는 특정 워크로드에서 응답성 및 안정성 측면에서 시스템의 성능을 판단합니다.
      - 성능 테스트에서는 확장성 제약, 소프트웨어 구성 문제 및 하드웨어 리소스 부족과 관련된 문제를 보여줍니다.
      - 이러한 테스트로 발견된 문제는 성능 병목 현상을 초래하고 문제를 해결하지 않으면 안정성이 저하될 수 있습니다.
    - 사용자 인터페이스(UI) 및 엔드 투 엔드 테스트
      - UI 및 엔드 투 엔드 테스트는 사용자 경험을 전체적으로 검사하여 애플리케이션이 사용자의 워크플로에 따라 올바르게 작동하는지 확인하며 일반적으로 더 복잡합니다.
  - 테스트 커버리지
    - 테스트 적용 범위를 평가할 때 얻을 수 있는 이점
      - 테스트 계획에 추가해야 하는 테스트 파악
      - 애플리케이션의 전반적인 품질 향상
      - 테스트를 파악하여 문제를 조기에 포착하고 시간과 리소스 절약
      - 중복되거나 요구 사항과 관련이 없는 테스트를 파악하여 테스트 범위 조정
      - 요구 사항 및 사용 사례가 정확하고 완전하며 일관성이 있는지 확인
- 모듈 2: DevOps 검토
  - DevOps 관행이 자동화에 제공하는 이점
    - DevOps 관행
      - 지속적 통합
        - 지속적 통합은 자동화된 빌드 및 테스트가 수행된 후, 개발자가 코드 변경 사항을 중앙 리포지토리에 정기적으로 병합하는 소프트웨어 개발 방식입니다.
      - 지속적 전달
        - 지속적 전달은 코드 변경이 자동으로 빌드 및 테스트되고 프로덕션 환경에 릴리스가 준비되는 소프트웨어 개발 방식입니다.
        - 빌드 단계 이후 모든 코드 변경 사항을 테스트 환경, 프로덕션 환경 또는 두 가지 환경 모두에 배포하여 지속적 통합을 확장합니다.
      - 지속적 배포
        - 지속적 배포는 코드 변경이 자동으로 빌드 및 테스트되고 프로덕션 환경에 릴리스되는 소프트웨어 개발 방식입니다.
        - 수동 프로세스가 필요하지 않으며 프로덕션 환경에 코드 변경 사항을 자동으로 배포하여 지속적 전달을 확장합니다.
      - 마이크로서비스
        - 마이크로서비스 아키텍처는 단일 애플리케이션을 작은 서비스의 집합으로 구축하는 설계 접근 방식입니다.
      - 코드형 인프라
        - 코드형 인프라는 버전 제어나 지속적 통합과 같은 코드 및 소프트웨어 개발 기법을 사용하여 인프라를 프로비저닝하고 관리하는 방식입니다.
      - 모니터링 및 로깅
        - 기업은 지표와 로그를 모니터링하여 애플리케이션 및 인프라 성능이 제품의 사용자 경험에 어떤 영향을 미치는지 확인합니다.
      - 커뮤니케이션 및 협업
        - 조직에서 커뮤니케이션과 협업이 증가하는 것도 DevOps의 주요 문화적 측면 중 하나입니다. DevOps 도구와 소프트웨어 전달 프로세스 자동화를 사용하면 개발 및 운영의 워크플로와 책임을 물리적으로 결합하여 협업이 이루어집니다.
    - 이점
      - 신속한 전달
        - 릴리스의 빈도와 속도를 개선하여 제품을 더 빠르게 혁신하고 개선할 수 있습니다.
        - 새로운 기능의 릴리스와 버그 수정 속도가 빨라질수록 고객의 요구에 더 빠르게 대응하여 경쟁 우위를 강화할 수 있습니다.
        - 지속적 통합과 전달은 빌드에서 배포까지 소프트웨어 릴리스 프로세스를 자동화하는 방식입니다.
      - 안정성
        - 최종 사용자에게 지속적으로 긍정적인 경험을 제공하는 한편 더욱 빠르게 안정적으로 제공할 수 있도록 애플리케이션 업데이트와 인프라 변경의 품질을 보장합니다.
        - 지속적 통합 및 전달과 같은 방식을 사용하여 각 변경 사항이 제대로 작동하며 안전한지 테스트합니다.
      - 크기 조정
        - 규모에 따라 인프라와 개발 프로세스를 운영 및 관리합니다.
        - 자동화와 일관성이 지원되므로 위험을 줄이면서 복잡한 시스템 또는 변화하는 시스템을 효율적으로 관리할 수 있습니다.
      - 협업 강화
        - 주인 의식 및 책임 의식과 같은 가치를 강조하는 DevOps 문화 모델을 바탕으로 좀 더 효과적인 팀을 구축합니다.
        - 개발자와 운영 팀은 긴밀하게 협력하고, 많은 책임을 공유하며, 워크플로를 결합합니다.
        - 이를 통해 비효율성을 줄이고 시간을 절약할 수 있습니다.
      - 보안
        - 제어를 유지하고 규정을 준수하면서 신속하게 진행할 수 있습니다.
        - 자동화된 규정 준수 정책, 세분화된 제어 및 구성 관리 기술을 사용함으로써 보안을 그대로 유지하면서 DevOps 모델을 도입할 수 있습니다.
        - 보안 관행이 좋지 않으면 민첩성을 저해하고, 취약점을 만들고, 구성에 오류가 생기며, 코드가 불안전해지는 등 아키텍처에 약점이 생길 수 있습니다.
  - 사용 가능한 도구
    - AWS CodeCommit
      - 안전한 Git 기반 리포지토리를 호스팅하는 완전관리형 소스 제어 서비스입니다.
      - 이 서비스를 사용하면 뛰어난 확장성의 안전한 에코시스템에서 여러 팀이 협업하여 코드 작업을 수행할 수 있습니다.
      - 완전관리형
        - CodeCommit을 사용하면 자체적으로 소스 제어 서버를 호스팅하고, 유지 관리하고, 백업하고, 확장할 필요가 없어집니다. 서비스가 프로젝트의 요구 사항이 늘어나는 것에 맞춰 자동으로 조정됩니다.
      - 보안
        - AWS CodeCommit은 전송 중이거나 상주 중인 파일을 자동으로 암호화합니다. CodeCommit을 AWS Identity and Access Management(IAM)와 통합하면 리포지토리에 대한 사용자별 액세스를 사용자 정의할 수 있습니다.
      - 고가용성
        - CodeCommit은 고도로 확장 가능하며 내구성 있는 중복 아키텍처를 보유하고 있습니다. 이 서비스는 리포지토리의 고가용성 및 액세스 가능성을 유지하도록 설계되었습니다.
      - 협업 방식의 코드 작업
        - CodeCommit의 가져오기 요청, 브랜치 생성 및 병합 기능을 사용하면 팀 동료와 협업하여 코드 작업을 수행할 수 있습니다.
        - 코드 검토 및 피드백이 기본적으로 포함되는 워크플로를 구현하고, 특정 브랜치를 변경할 수 있는 사용자를 제어할 수 있습니다.
      - 더 빠른 개발 주기
        - CodeCommit은 AWS 클라우드의 빌드, 스테이징 및 프로덕션 환경 가까이에 리포지토리를 유지합니다.
        - 전체 애플리케이션이 아닌 바뀐 부분만 전송할 수 있습니다. 이를 통해 개발 수명 주기의 속도와 빈도를 높일 수 있습니다.
      - 기존 도구 사용
        - CodeCommit은 모든 Git 명령을 지원하며 기존 Git 도구와 연동됩니다.
        - CodeCommit을 사용하여 선호하는 개발 환경 플러그 인, CI/CD 시스템 및 그래픽 클라이언트를 계속 사용할 수 있습니다.
    - AWS CodeBuild
      - 소스 코드를 컴파일하고 테스트를 실행하며 배포할 준비가 된 소프트웨어 패키지를 생성하는 완전관리형 지속적 통합 서비스입니다.
      - 완전관리형 빌드 서비스
        - AWS CodeBuild는 기업이 자체적으로 빌드 서버 및 소프트웨어를 설정, 패치, 업데이트 및 관리할 필요성을 제거합니다.
        - 설치 또는 관리가 필요한 소프트웨어가 없습니다.
      - 지속적 크기 조정
        - AWS CodeBuild는 빌드 볼륨에 따라 자동으로 확장 및 축소됩니다.
        - 제출되는 빌드는 그때마다 즉각적으로 처리되며, 각 빌드를 동시에 실행할 수 있기 때문에 빌드가 대기열에 남겨지는 일이 없습니다.
      - 확장성
        - CodeBuild에서 지원하는 사전 패키지 형태의 빌드 도구 및 런타임에 더해 자체 빌드 도구와 프로그래밍 런타임을 CodeBuild에서 사용하고 사용자 정의 빌드 환경을 생성할 수 있습니다.
      - 지속적 통합 및 전달 지원
        - AWS CodeBuild는 AWS 개발자 도구 제품군에 속합니다. 즉, 이 서비스를 사용하여 CI/CD(지속적 통합 및 전달)를 위한 완전한 자동 소프트웨어 릴리스 워크플로를 생성할 수 있습니다.
        - CodeBuild를 기존 CI/CD 워크플로에 통합하는 것도 가능합니다.
      - 보안
        - CodeBuild에서는 고객이 지정하고 AWS Key Management Service(AWS KMS)로 관리되는 키를 사용해 빌드 아티팩트가 암호화됩니다.
        - CodeBuild는 IAM과 통합되므로 빌드 프로젝트에 사용자별 권한을 할당할 수 있습니다.
    - AWS CodeDeploy
      - 다양한 컴퓨팅 서비스에 소프트웨어 배포를 자동화하는 완전관리형 배포 서비스입니다.
      - Amazon Elastic Compute Cloud(Amazon EC2), AWS Fargate, AWS Lambda와 같은 플랫폼과 온프레미스 서버에 애플리케이션을 배포합니다.
      - CodeDeploy를 사용하면 새로운 기능을 더욱 쉽고 빠르게 릴리스할 수 있고, 애플리케이션을 배포하는 동안 가동 중지 시간을 줄이는 데 도움이 되며, 복잡한 애플리케이션 업데이트 작업을 처리할 수 있습니다. CodeDeploy를 사용하여 소프트웨어 배포를 자동화함으로써 오류가 발생하기 쉬운 수동 작업을 제거할 수 있습니다. 이 서비스는 배포 요구 사항에 맞게 확장됩니다.
      - 자동 배포
        - AWS CodeDeploy에서 소프트웨어 배포를 완전히 자동화하므로 신속하고 안정적으로 배포할 수 있습니다.
        - Amazon EC2, Fargate, Lambda 또는 온프레미스 서버 중 어디에 배포하든 관계없이 개발, 테스트 및 프로덕션 환경에 걸쳐 일관되게 애플리케이션을 배포할 수 있습니다. 인프라에 따라 서비스가 확장됩니다.
      - 가동 중지 시간 최소화
        - AWS CodeDeploy는 소프트웨어 배포 프로세스 동안 애플리케이션의 가용성을 최대화하도록 지원합니다.
        - 변경 사항을 점진적으로 도입하고 구성 가능한 규칙에 따라 애플리케이션 상태를 추적합니다.
        - 오류가 발생하는 경우 손쉽게 소프트웨어 배포를 중단하고 롤백할 수 있습니다.
      - 중앙 집중식 제어
        - AWS CodeDeploy를 사용하면 AWS 관리 콘솔 또는 AWS Command Line Interface(AWS CLI)를 통해 손쉽게 애플리케이션 배포를 시작하고 해당 배포 상태를 추적할 수 있습니다. CodeDeploy에서는 상세한 보고서를 제공하므로 각 애플리케이션 수정 버전이 언제 어디에 배포되었는지 확인할 수 있습니다.
        - 배포에 대한 라이브 업데이트를 받도록 푸시 알림을 생성할 수 있습니다.
      - 손쉬운 도입
        - AWS CodeDeploy는 플랫폼과 언어에 구애를 받지 않고, 모든 애플리케이션과 연동되며, Amazon EC2, Fargate, AWS Lambda 등 어디에 배포하든 동일한 환경을 제공합니다. 또한, 기존 설정 코드를 쉽게 재사용할 수 있습니다.
        - CodeDeploy는 기존 소프트웨어 릴리스 프로세스나 지속적 전달 도구 체인(예: CodePipeline, GitHub, Jenkins)과도 통합할 수 있습니다.
    - AWS CodePipeline
      - 빠르고 안정적인 애플리케이션 및 인프라 업데이트를 위해 릴리스 파이프라인을 자동화하는 데 도움이 되는 완전관리형 지속적 전달 서비스입니다.
      - CodePipeline은 코드 변경이 발생할 때마다 사용자가 정의한 릴리스 모델을 기반으로 릴리스 프로세스의 빌드, 테스트 및 배포 단계를 자동화합니다.
      - 기능과 업데이트를 신속하고 안정적으로 제공할 수 있습니다.
      - CodePipeline을 GitHub와 같은 서드 파티 서비스 또는 자체 사용자 정의 플러그 인과 손쉽게 통합할 수 있습니다. AWS CodePipeline에서는 사용한 만큼만 비용을 지불합니다. 선결제 수수료나 장기 약정은 없습니다.
      - 신속한 전달
        - CodePipeline은 소프트웨어 출시 프로세스를 자동화하므로 새로운 기능을 신속하게 릴리스할 수 있습니다. CodePipeline을 사용하면 피드백에 따라 신속하게 반복하고 사용자에게 새로운 기능을 더 빠르게 제공할 수 있습니다.
        - 빌드, 테스트 및 릴리스 프로세스를 자동화하면 각 코드 변경 사항을 빠르고 쉽게 테스트하며 버그가 아직 작고 간단하게 해결할 수 있을 때 버그를 포착할 수 있습니다. 각 변경 사항은 스테이징 및 릴리스 프로세스를 거치므로 애플리케이션 또는 인프라 코드의 품질을 보장할 수 있습니다.
      - 구성 가능한 워크플로
        - AWS CodePipeline을 사용하면 콘솔 인터페이스, AWS CLI, AWS CloudFormation 또는 AWS SDK를 사용하여 소프트웨어 릴리스 프로세스의 여러 단계를 모델링할 수 있습니다.
        - 손쉽게 실행할 테스트를 지정하고 애플리케이션과 관련 종속성을 배포할 단계를 사용자 정의할 수 있습니다.
      - 빠른 시작
        - CodePipeline을 사용하면 소프트웨어 릴리스 프로세스 모델링을 즉시 시작할 수 있습니다.
        - 프로비저닝하거나 설정할 서버가 없습니다. CodePipeline은 기존 도구와 시스템에 연결할 수 있는 완전관리형의 지속적 전달 서비스입니다.
      - 손쉬운 통합
        - AWS CodePipeline은 특정한 요구에 맞게 손쉽게 확장할 수 있습니다.
        - AWS의 사전 구축된 플러그인 또는 자체 사용자 정의 플러그 인을 릴리스 프로세스 중 원하는 단계에 사용할 수 있습니다.
        - 예를 들어 GitHub에서 소스 코드를 가져오거나 온프레미스 Jenkins 빌드 서버를 사용할 수 있습니다. 서드 파티 서비스를 사용하여 로드 테스트를 실행하거나 배포 정보를 사용자 정의 작업 대시보드에 전달할 수 있습니다.
  - 서버리스 및 서드 파티
    - GitHub
    - CloudBees
    - Jenkins
    - TeamCity
    - Ghost Inspector
- 모듈 3: 지속적 통합
  - 코드 표준
    - 코드 표준 예시
      - 메서드의 최대 파라미터 수
      - 주석 사용
      - 변수, 함수, 메서드의 이름 지정 방법
      - 메서드 복잡성
      - 보안 표준
      - 접근성
    - 코드 표준 목표
      - 안전하며 해를 끼치지 않고 사용할 수 있는 코드
      - 보안이 되어 있으며 해킹할 수 없는 코드
      - 안정적이며 항상 예상대로 작동하는 코드
      - 테스트 가능한 코드
      - 읽기 쉽고 이해하기 쉬운 코드
      - 다른 환경으로 이동 가능한 코드
    - 산업 코드 표준
      - CERT C : CERT C는 C 프로그래밍 언어에 대한 소프트웨어 프로그래밍 표준입니다. CERT C는 취약성을 유발할 수 있는 코드를 식별하고 안전하고 안정적이며 보안 태세를 갖춘 시스템을 개발하기 위한 규칙을 제공합니다.
      - MISRA C : Motor Industry Software Reliability Association(MISRA) C는 코드 안전, 보안, 이동성, 신뢰성에 중점을 둔 소프트웨어 개발 지침으로, 다른 부문의 모범 사례에서 널리 인정되는 모델입니다.
      - AUTOSAR C++ : Automotive Open System Architecture(AUTOSAR)는 자동차 소프트웨어의 기능을 표준화하기 위해 만들어졌고. C++에 대한 코드 표준을 수립했습니다.
      - PEP 8 : PEP(Python Enhancement Proposal) 8은 파이썬을 코딩하는 스타일 가이드입니다. PEP 8은 Python 코드의 가독성과 일관성을 향상하는 데 중점을 둡니다.
      - PSR : PHP Standards Recommendations(PSR)의 목표는 구성 요소의 상호 운용성을 가능하게 하는 것입니다. 또한 최적의 프로그래밍 및 테스트 사례를 위한 검증된 개념을 구현하기 위한 공통의 기술적 기반을 제공합니다.
  - 린팅
    - 린터(Linter)는 코드를 검사하여 구문 문제 또는 코드를 실행할 때 오류로 이어질 수 있는 버그를 찾는 프로그램입니다. 린터는 빌드 자동화 또는 작성 도구에 통합할 수 있습니다.
    - PyLint
      - Python용 소스 코드, 버그 및 품질 검사기
      - PEP 8 스타일 가이드 권장 사항을 따름
  - 단위 테스트
    - 단위 테스트의 역할
      - 단위 테스트의 주요 목적은 소프트웨어 단위가 설계된 대로 작동하는지 확인하는 것입니다.
      - 단위 테스트는 개별 애플리케이션 코드 단위의 문제를 신속하게 식별하고 격리하는 데 유용합니다.
      - 각 브랜치에 대한 모든 커밋은 자동 테스트를 트리거해야 합니다. 단위 테스트는 컴파일된 코드에서 실행됩니다. 그러면 개발자가 리포지토리에 코드를 커밋할 때 코드가 변경되어도 이전 코드가 손상되지 않습니다.
      - 단위 테스트의 품질을 나타내는 한 가지 척도는 코드 적용 범위입니다. 코드 적용 범위는 테스트되는 소스 코드의 양을 측정합니다.
    - 이점
      - 테스트는 소프트웨어 개발 단계 초기에 실행하여 버그를 조기에 포착할 수 있습니다.
      - 단위 테스트 단계에서 문제를 해결하는 데 드는 비용은 이후 테스트 단계에서보다 낮습니다.
      - 코드 적용 범위를 측정할 수 있습니다.
      - 코드 완성도는 단위 테스트를 통해 입증할 수 있습니다.
      - 개발 시간이 단축됩니다.
    - 모범 사례
      - 모든 코드 변경에 실행하여 품질을 확인합니다.
      - 코드 적용 범위를 양호하게 설정합니
      - 코드 단위를 격리하여 테스트합니다.
      - 빠르게 실행하고 신속하게 실패합니다.
  - 테스트 주도 개발과 동작 기반 개발
    - 소프트웨어 개발 프로젝트에는 TDD(테스트 주도 개발)와 동작 기반 개발(BDD)의 두 가지 방법론이 사용됩니다.
    - TDD와 BDD의 이점 중 하나는 요구 사항의 오류가 조기에 발견되어 개발 팀에 도움이 되며 전반적인 비용을 절감할 수 있다는 것입니다.
      - BDD는 최종 사용자가 경험하는 애플리케이션의 동작에 중점을 둡니다.
      - TDD는 기능에 중점을 둡니다.
    - TDD
      - TDD는 매우 짧은 개발 주기가 반복되는 데 의존하는 소프트웨어 개발 프로세스입니다. TDD 개발은 단순한 설계를 장려하고 코드에 대한 자신감을 고취시킵니다. 이 프로세스는 요구 사항을 테스트 케이스로 변환한 후 코드를 작성하거나 개선하여 테스트 케이스를 통과합니다.
      - 프로젝트에 추가되는 모든 새 기능에 대해 먼저 테스트를 작성하는 것으로 시작합니다. 사용 사례와 사용자 스토리는 개발자가 요구 사항을 이해하는 데 도움이 될 수 있습니다.
      - 테스트를 실행하여 개발자가 테스트 도구가 올바르게 작동하는지 확인할 수 있도록 새 테스트가 실패하는지 확인합니다. 테스트가 처음 실행될 때 실패할 것입니다.
      - 테스트를 통과하도록 할 코드를 작성합니다.
      - 테스트를 실행하고 새 코드가 통과하는지 확인합니다.
      - 코드를 리팩터링하고, 중복을 제거하고, 이전 코드를 정리합니다.
      - 새로운 테스트 주기로 시작하여 반복합니다.
    - BDD
      - BDD는 개발자, 품질 보증 및 비즈니스 파트너 간의 협업을 장려하는 민첩한 소프트웨어 개발 프로세스입니다.
      - 팀이 대화와 구체적인 예시를 사용하여 애플리케이션의 작동 방식에 대한 이해를 공식화하도록 장려합니다.
      - 동작 기반 개발은 TDD가 확장된 것으로, 간단한 단순한 도메인별 스크립팅 언어(DSL)를 사용합니다. DSL은 테스트로 변환할 수 있습니다.
      - DSL에는 다음과 같은 기능이 있습니다.
        - 사용자의 동작이 간단한 영어로 정의됩니다.
        - 영어 단어는 함수 코드에 맞게 자동 스크립트로 변환됩니다.
        - 개발 팀은 테스트 케이스를 통과하도록 코드를 작성합니다.
        - 사용자 동작은 시나리오를 기반으로 하는 경우가 많습니다. 예:
          - 한 사용자가 사이트를 방문함
          - 사용자가 주문 버튼을 클릭함
          - 사용자가 주문 페이지에 액세스함
  - 프레임워크 도구 예시
    - JUnit
      - Java 프로그래밍 언어용 테스트 프레임워크
      - 첫 번째 테스트 후 코딩 방법론 촉진
      - 오픈 소스
      - 개발자의 생산성과 코드 품질 향상에 도움이 됨
      - 개발자가 단위 테스트를 생성하는 데 매우 유용한 도구
    - PyTest
      - 모든 기능을 갖춘 Python 테스트 도구
      - 테스트를 확장 가능하고 쉽게 구축 가능
      - 이해하기 쉬운 구문
      - Pip과 함께 설치할 수 있음
  - 풀 요청
    - 풀 요청 수명 주기
      - 병합할 새 기능은 하나 이상의 커밋으로 기능 브랜치에 추가됩니다. 커밋은 대상 브랜치에 병합되지 않습니다.
      - 풀 요청은 두 브랜치의 차이로부터 생성됩니다.
      - 팀원은 풀 요청을 검토하고 댓글을 남깁니다.
      - 검토자의 댓글에 따라 변경 사항이 포함된 추가 커밋으로 풀 요청을 업데이트할 수 있습니다.
      - 대상 브랜치를 변경할 수 있습니다.
      - 모든 팀원이 풀 요청에 만족하면 풀 요청을 대상 브랜치로 병합할 수 있습니다.
      - 커밋은 풀 요청에 추가된 순서와 동일한 순서로 대상 브랜치에 적용됩니다.
      - 변경 사항이 병합된 후 기능 브랜치를 삭제합니다.
    - 브랜치 병합
      - FAST-FORWARD 병합
        - Fast-forward는 참조 브랜치를 소스 브랜치의 가장 최근 커밋으로 전진시킵니다. 커밋 기록은 대상 브랜치에서 발생한 것처럼 유지됩니다. 소스 브랜치의 팁은 대상 브랜치의 팁으로 빠르게 넘어갑니다.
      - 스쿼시 및 병합
        - 스쿼시 및 병합 풀 요청 커밋은 하나의 커밋으로 결합됩니다.
      - 3방향 병합
        - 3방향 병합은 대상 브랜치에 병합을 생성하지만 기록의 일부로 개별 커밋을 유지합니다.
- 모듈 4: 지속적 전달
  - 기능 테스트
    - 기능 테스트를 위한 프로세스
      - 모든 기능 테스트에서 목표는 소프트웨어 결함을 발견하고 소프트웨어 품질을 높이기 위해 코드가 실패하도록 하는 것입니다. 기능 테스트는 6단계로 이루어집니다.
        - 소프트웨어가 수행할 것으로 예상되는 함수를 식별합니다.
        - 함수의 사양에 따라 입력 데이터를 생성합니다.
        - 함수의 사양에 따라 함수 출력을 결정합니다.
        - 테스트 케이스를 실행합니다.
        - 실제 출력값과 예상 출력값을 비교합니다.
        - 고객 요구에 따라 기능이 작동하는지 확인합니다.
  - 성능 테스트
    - 유형
      - 로드 테스트
        - 로드 중인 시스템의 성능을 판단합니다.
        - 테스트 스크립트를 사용하여 여러 사용자가 동시에 시스템에 액세스하는 것을 시뮬레이션합니다.
        - 애플리케이션의 서비스 품질을 측정합니다.
      - 스트레스 테스트
        - 시스템의 한계를 파악합니다.
        - 소프트웨어의 장애 시점을 발견합니다.
        - 장애 복구 시간이 얼마나 걸리는지 확인하는 데 유용합니다.
      - 소크 테스트(내구성 테스트)
        - 일반적인 워크로드를 오랜 기간 동안 실행합니다.
        - 메모리 누수와 같은 잠재적 문제를 확인합니다.
        - 예기치 않은 로드를 얼마 동안 유지할 수 있을지 판단하는 데 유용합니다.
      - 스파이크 테스트
        - 신속하고 반복적으로 워크로드를 증가합니다.
        - 로드의 급격한 증가 또는 감소가 성능에 영향을 미치는지 확인하는 데 유용합니다.
      - 중단점 테스트
        - 시스템이 SLA(서비스 수준 계약)를 충족하면서 실행할 수 있는 최대 용량을 측정합니다.
        - 스케일아웃 이벤트를 결정하는 데 어떤 지표를 사용해야 하는지 결정하는 데 유용합니다.
      - 구성 테스트
        - 구성 변경의 영향을 테스트합니다.
        - 하드웨어와 소프트웨어의 최적 조합을 결정하는 데 유용합니다.
      - 격리 테스트
        - 시스템 문제를 일으킨 테스트를 반복하여 오류를 확인합니다.
        - 오류 도메인을 격리하고 확인하는 데 유용합니다.
    - 수집할 핵심 성과 지표(예)
      - 평균 응답 시간
      - 피크 응답 시간
      - 오류율
      - 동시 사용자
      - 초당 요청
      - 처리량
  - 사용자 수용 테스트
    - 실제 시나리오
      - 가장 일반적인 태스크 실행
      - 가장 어려운 태스크 수행
      - 주로 테스트 시나리오에 대해 실행
      - 사용자 스토리의 기능 테스트일 수 있음
    - 알파 베타 테스트
      - 알파 테스트는 개발 환경에서 수행됩니다.
      - 베타 테스트는 클라이언트 사이트에서 현장 테스트로 수행됩니다.
    - 규제 수용 테스트
      - 소프트웨어가 관련 규정을 준수하는지 테스트합니다.
    - 블랙박스 테스트
      - 이 테스트는 시스템 내부에 대한 지식이 없이 입력과 출력을 확인합니다.
  - 가상 테스트
    - 가상 테스트는 동작을 예측하여 애플리케이션에서 사용자의 경험을 이해하는 방법입니다. 종종 웹 브라우저 에뮬레이션 또는 웹 트랜잭션의 스크립팅된 기록을 사용하여 수행됩니다. 
    - 최종 사용자가 사이트에서 수행할 경로나 작업을 시뮬레이션하기 위해 스크립트가 만들어집니다.
    - 용도
      - 애플리케이션 가동 시간을 모니터링합니다.
      - 국가별 실적 기준을 수립합니다.
      - 성능을 모니터링합니다.
      - 서드 파티 스크립트로 인해 발생하는 문제를 감지합니다.
      - 데이터베이스 가동 시간을 모니터링합니다.
    - 단점
      - 사용자 작업이 시뮬레이션됩니다.
      - 실제 사용자는 가상 테스트에서 포착하지 않은 다른 문제를 경험할 수 있습니다.
- 모듈 5: 지속적 배포
  - 롤링 배포
    - 롤링 배포를 사용하면 프로덕션 플릿이 그룹으로 나뉘어 전체 플릿이 한 번에 업그레이드되지 않습니다. 
    - 플릿은 배포 프로세스 중에 새 소프트웨어 버전과 기존 소프트웨어 버전을 모두 실행합니다. 이 방법을 사용하면 가동 중지 시간 없이 업데이트가 가능합니다. 배포에 실패하면 플릿의 업그레이드된 부분만 영향을 받습니다.
  - 상태 확인
    - 실시간 검사
      - 실시간 검사는 서비스에 대한 기본 연결성과 서버 프로세스의 존재를 테스트합니다. 
      - 종종 로드 밸런서나 외부 모니터링 에이전트가 실시간 검사를 수행하며, 애플리케이션의 작동 방식에 대한 세부 정보는 알지 못합니다. 
      - 실시간 검사는 서비스에 포함되기도 하고, 애플리케이션 작성자는 아무런 구현 작업도 수행할 필요가 없습니다. 
      - 다음은 Amazon에서 사용하는 실시간 검사의 몇 가지 예입니다.
        - 서버가 예상 포트에서 수신하며 새로운 TCP 연결을 수용하고 있는지 확인하는 테스트
        - 기본 HTTP 요청을 수행하고 서버가 200 상태 코드로 응답하는지 확인하는 테스트
        - 어느 시스템이나 작동하는 데 필요한 기본 사항(예: 네트워크 연결 가능성)을 테스트하는 Amazon EC2용 상태 확인
    - 로컬 상태 확인
      - 로컬 상태 확인은 실시간 검사보다 더 나아가 애플리케이션이 작동할 수 있는지를 검증합니다. 
      - 이러한 상태 확인은 서버 피어와 공유하지 않는 리소스를 테스트합니다. 
      - 따라서 플릿의 많은 서버에서 동시에 실패할 가능성이 낮습니다. 
      - 상태 확인에서 확인할 수 있는 상황의 몇 가지 예는 다음과 같습니다.
        - 디스크에서 쓰기 또는 읽기 불가능: 무상태 서비스는 쓰기 가능한 디스크를 필요로 하지 않는다고 생각하기 쉽습니다. 많은 서비스가 비동기 미터링 데이터 모니터링, 로깅 및 게시와 같은 용도로 디스크를 사용하는 경향이 있습니다.
        - 중요한 프로세스 충돌 또는 중단: 일부 서비스는 서버 내 프록시(NGINX와 유사)를 사용하여 요청을 수행하고 다른 서버 프로세스에서 비즈니스 로직을 수행합니다. 실시간 검사는 프록시 프로세스가 실행 중인지만 테스트할 수 있습니다. 로컬 상태 확인 프로세스는 프록시에서 애플리케이션을 통과하며 둘 다 실행 중이고 요청에 올바르게 응답하는지 확인할 수 있습니다.
        - 누락된 지원 프로세스 - 모니터링 데몬이 누락된 호스트의 경우 운영자는 서비스 상태를 알지 못할 수 있습니다. 다른 지원 프로세스는 측정 및 청구 사용량 레코드를 푸시하거나 자격 증명 업데이트를 수신합니다. 지원 프로세스가 중단된 서버는 감지하기 어려운 미묘한 방식으로 기능을 위험에 빠뜨립니다.
    - 종속성 상태 확인
      - 종속성 상태 확인은 인접한 시스템과 상호작용하는 애플리케이션의 기능을 조사하는 철저한 검사입니다. 
      - 이러한 검사는 이상적으로는 종속성과의 상호작용을 방해하는 만료된 자격 증명과 같이 서버에 로컬로 존재하는 문제를 포착합니다. 
      - 하지만 종속성 자체에 문제가 있어도 거짓 긍정을 보유할 수 있습니다. 이러한 거짓 긍정 때문에 종속성 상태 확인 실패에 대응하는 방법을 신중하게 고려해야 합니다. 
      - 종속성 상태 확인에서는 다음을 테스트할 수 있습니다.
        - 프로세스가 비동기적으로 메타데이터 또는 구성에 대한 업데이트를 찾지만 서버에서 업데이트 메커니즘이 손상되어 있을 수 있습니다. 서버가 피어와 상당히 비동기화된 상태일 수 있습니다. 예측할 수 없고 테스트되지 않은 방식으로 서버가 오작동할 수 있습니다. 서버가 업데이트를 확인하지 못하면 업데이트 메커니즘이 중단되었는지 여부와 중앙 업데이트 시스템이 업데이트 게시를 중지했는지 여부를 알지 못합니다.
    - 이상 탐지
      - 이상 탐지는 플릿의 모든 서버를 관찰하고 피어와 비교했을 때 서버가 이상하게 동작하는지 확인합니다. 
      - 서버당 모니터링 데이터를 집계하여 지속적으로 오류 비율, 대기 시간 데이터 또는 기타 속성을 비교하여 이상 서버를 찾고 서비스에서 자동으로 제거할 수 있습니다. 
      - 이상 탐지는 다음과 같이 서버가 자체적으로 탐지할 수 없는 플릿의 일탈 조건을 찾아낼 수 있습니다.
        - 클록 스큐: 서버의 로드가 높을 때 클록이 갑자기 급격하게 왜곡되는 것으로 알려져 있습니다. 서명을 포함한 요청을 평가하는 데 사용되는 방법과 같은 보안 조치에서는 클라이언트 클록의 시간이 실제 시간의 5분 이내여야 합니다. 5분 이상이면 요청이 실패합니다.
        - 이전 코드: 서버가 네트워크에서 연결이 끊어지거나 오랜 시간 동안 전원이 꺼진 상태일 수 있습니다. 다시 온라인 상태가 되면 나머지 플릿과 호환되지 않는 아주 오래된 코드가 실행될 수 있습니다.
        - 예상치 못한 실패 모드: 자체 오류가 아닌 클라이언트 오류로 식별하는 오류(HTTP 500이 아닌 HTTP 400)를 반환하여 서버가 실패하는 경우가 있습니다. 서버는 실패하는 대신 속도가 느려지거나 피어보다 더 빠르게 응답할 수 있습니다. 이는 발신자에게 거짓 응답을 반환하는 상황을 나타냅니다. 이상 탐지는 예상하지 못한 실패 모드에 대해 여러 측면에서 뛰어난 성능을 보여줍니다.
  - 배포 유형
    - 인 플레이스(IN-PLACE) 배포
      - 각 인스턴스에 있는 애플리케이션이 중지되고 최신 애플리케이션 개정판이 설치되며 애플리케이션의 새 버전이 시작되고 유효성이 검증됩니다. Amazon EC2 또는 온프레미스 컴퓨팅 플랫폼을 사용하는 배포만 인 플레이스 배포를 사용할 수 있습니다.
    - 블루/그린 배포
      - 블루/그린 배포는 새로운 애플리케이션 버전의 변경으로 인한 중단을 최소화하면서 애플리케이션을 업데이트하는 데 사용됩니다. CodeDeploy는 프로덕션 트래픽을 다시 라우팅하기 전에 이전 버전과 함께 새 애플리케이션 버전을 프로비저닝합니다. 즉, 배포 중에 두 가지 버전의 애플리케이션이 동시에 실행된다는 것을 의미합니다.
      - 블루/그린 배포는 인 플레이스 배포에 비해 여러 가지 이점을 제공합니다. 
        - 블루 환경을 방해하지 않고 그린 환경에서 테스트
        - 그린 환경으로 전환해도 다운타임이 발생하지 않음.
        - 사용자 트래픽 리디렉션만 필요함.
        - 문제가 있을 경우 그린 환경에서 블루 환경으로 롤백하기가 쉬움.
        - 트래픽을 다시 빌드하지 않고도 블루 환경으로 트래픽을 리디렉션할 수 있음.
        - 변경해야 할 때 새로운 인스턴스를 프로비저닝하여 구성 드리프트를 방지할 수 있음. 이 때 인프라 불변성의 원칙이 포함됨.
      - 블루/그린 배포를 사용하는 경우 트래픽을 새로운 그린 환경으로 전환하는 데 다음과 같은 옵션이 있습니다.
        - Canary
          - 첫 번째 증분에서 업데이트된 애플리케이션 버전으로 이동되는 트래픽의 비율을 지정하는 미리 정의된 canary 옵션 중에서 선택할 수 있습니다. 그런 다음 분 단위로 지정된 간격은 두 번째 증분에서 나머지 트래픽이 이동되는 시점을 나타냅니다.
        - 선형
          - 트래픽이 동일한 증분으로 이동하며 각 증분 간에 시간(분)이 동일합니다. 각 증분에서 이동되는 트래픽 비율(%)과 각 증분 간의 시간(분)을 지정하는 사전 정의된 선형 옵션에서 선택할 수 있습니다.
        - 한 번에 모두
          - 모든 트래픽이 원래 환경에서 업데이트된 환경으로 한 번에 이동됩니다.
- 수동 승인
  - 파이프라인의 다음 단계에 개정이 허용되기 전에 다른 사용자가 코드 검토를 수행하거나 관리 검토를 변경하도록 합니다.
  - 릴리스되기 전에 다른 사용자가 최신 버전의 애플리케이션에 대한 수동 품질 보증 테스트를 수행하거나 빌드 아티팩트의 무결성을 확인하도록 합니다.
  - 회사 웹 사이트에 게시되기 전에 다른 사용자가 신규 또는 업데이트된 텍스트를 검토하도록 합니다.
- 자동 승인
  - 승인에 접근하는 보다 효율적인 방법은 프로세스를 자동화하는 것입니다. 
  - 승인 주기에 자동화를 도입하면 수동 리소스의 대기 시간을 없애 가용성을 높이고 규정된 테스트를 수행하게 할 수 있습니다. 
  - 테스트가 매번 같은 방식으로 실행되고 테스트를 건너뛰지 않기 때문에 안정성이 향상됩니다. 따라서 애플리케이션의 배포 시간을 단축하고 품질을 높일 수 있습니다.
- 프로모션 중단
  - 자동 롤백
    - 배포에 실패한 경우 또는 지정한 모니터링 임계값에 도달한 경우 자동으로 롤백하도록 배포 그룹 또는 배포를 구성할 수 있습니다. 이러한 경우 애플리케이션 개정판의 마지막으로 알려진 정상 버전이 배포됩니다. 
    - 자동 롤백은 애플리케이션을 만들거나 배포 그룹을 만들거나 업데이트할 때 구성합니다.
  - 수동 롤백
    - 자동 롤백을 설정하지 않은 경우 배포를 수동으로 롤백할 수 있습니다. 이 작업은 이전에 배포된 애플리케이션 개정판을 사용하는 새 배포를 만들고 개정을 재배포하는 단계에 따라 수행됩니다. 애플리케이션이 알 수 없는 상태인 경우 이 작업을 수행할 수 있습니다. 
    - 문제를 해결하는 데 많은 시간을 투자하는 대신 잘 알려진 작동 상태로 애플리케이션을 재배포할 수 있습니다.
- 샌드박스 환경 생성
  - CloudFormation 템플릿의 출력
    - CloudFormation 템플릿은 다음 리소스를 배포하여 샌드박스 환경을 만듭니다.
      - 샘플 웹 애플리케이션을 배포하기 위한 여러 단계(소스, 빌드, 테스트, 승인, 배포)가 포함된 CI/CD 기능을 갖춘 AWS CodePipleine
      - 샘플 애플리케이션 코드를 호스트하기 위한 AWS CodeCommit
      - 아티팩트를 빌드하고 샘플 웹 애플리케이션에 단위 테스트를 수행하기 위한 AWS CodeBuild 프로젝트
      - 샘플 웹 애플리케이션을 배포하기 위한 AWS CodeDeploy 애플리케이션
      - 코드를 변경한 다음 리포지토리를 업데이트하는 데 사용할 수 있는 AWS Cloud9 Integrated Development Environment(IDE)
      - 테스트 목적으로 Application Load Balancer를 사용하여 Amazon EC2 인스턴스에서 호스트되는 샘플 웹 애플리케이션
      - 정적 코드 테스트를 수행하기 위한AWS Lambda 함수
      - 샘플 웹 애플리케이션을 호스트하는 데 필요한 지원 인프라
