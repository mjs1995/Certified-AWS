# Amazon EKS Primer
- Amazon EKS Primer
  - Amazon Elastic Kubernetes Service
    - Amazon Elastic Kubernetes Service(Amazon EKS)는 AWS Cloud 또는 온프레미스에서 Kubernetes 애플리케이션의 배포, 관리 및 크기 조정을 용이하게 하는 관리형 컨테이너 오케스트레이션 서비스입니다.
    - Amazon EKS는 패치, 노드 프로비저닝 및 업데이트와 같은 주요 작업을 자동화하는 데도 도움을 줍니다.
  - 컨테이너 오케스트레이션의 필요성
    - 컨테이너는 애플리케이션의 코드, 구성 및 종속성을 하나의 객체로 패키징하는 표준화된 방식을 제공합니다.
    - 컨테이너는 가벼울 뿐만 아니라, 애플리케이션을 어디서나 실행하고 확장하기 위한 일관되고 이동 가능한 소프트웨어 환경을 제공합니다.
    - 컨테이너에 대해 잘 알려진 용례 가운데는 마이크로서비스 구축 및 배포, 배치 작업 실행, 머신러닝 애플리케이션 지원, 기존 애플리케이션을 클라우드로 이동하는 기능 등이 있습니다.
    - 컨테이너에서 실행하는 애플리케이션을 사용하려면 배치를 관리하고 확장하기 위한 컨테이너 오케스트레이션 플랫폼이 필요합니다.
  - 주요 카테고리
    - 컨테이너 스케줄링 및 배치
    - 컨테이너 수를 자동으로 적절하게 스케일 인 또는 스케일 아웃
    - 비정상 컨테이너를 자동으로 제거하고 그 위치에 새 컨테이너를 배포하여 서비스를 자가 치유
    - 네트워킹 서비스 및 영구 스토리지와 같은 클라우드 및 기타 서비스와의 통합
    - 시스템 보안, 모니터링 및 로깅
- Kubernetes
  - Kubernetes 객체
    - 클러스터
      - 컨테이너화된 애플리케이션을 실행하는 노드라는 일련의 작업자 머신입니다.
      - 모든 클러스터에는 하나 이상의 작업자 노드가 있습니다. 또한 클러스터에는 클러스터를 관리하는 서비스를 실행하는 제어 영역도 있습니다.
    - 노드
      - Kubernetes는 컨테이너를 포드에 그룹화하고 노드에서 실행할 이러한 포드를 할당함으로써 워크로드를 실행합니다.
      - 노드는 클러스터에 따라 가상이거나 물리적 머신일 수 있습니다. 각 노드는 제어 영역에서 관리되고 포드를 실행하는 데 필요한 서비스를 포함합니다.
    - 포드
      - 하나 이상의 컨테이너로 구성된 그룹입니다.
      - 포드는 컨테이너 실행 방법에 대한 사양인 PodSpec 파일에 의해 정의됩니다.
      - 포드는 배포, 크기 조정 및 복제를 위한 Kubernetes 내 기본 빌딩 블록입니다.
    - 볼륨
      - 휘발성 볼륨
        - 포드에 있는 애플리케이션은 공유 볼륨에 액세스하여 포드에서 데이터 공유 및 컨테이너 재시작 간 데이터의 지속성 유지를 용이하게 합니다.
        - 포드가 종료되면 Kubernetes는 휘발성 볼륨을 파괴합니다.
      - 영구 볼륨
        - 영구 볼륨은 휘발성 볼륨과 유사하게 기능하지만 수명 주기가 이를 사용하는 개별 포드와 무관합니다.
        - 영구 볼륨은 클러스터 노드와 상관 없이 스토리지 하위 시스템에서 지원됩니다.
    - 서비스
      - Kubernetes에서 서비스는 포드의 논리적 컬렉션이며 포드에 액세스하기 위한 수단입니다.
      - 서비스는 사용 가능한 포드 세트를 바탕으로 지속적으로 업데이트되어 포드가 다른 포드를 추적할 필요가 없습니다.
    - 네임스페이스
      - 동일한 물리적 클러스터에서 지원되는 가상 클러스터입니다.
      - 물리적 클러스터는 서로 다른 네임스페이스에 있다면 리소스가 동일한 이름을 가질 수 있습니다.
      - 특히 네임스페이스는 여러 팀이나 프로젝트가 동일한 클러스터를 사용할 때 유용합니다.
    - ReplicaSet
      - 언제든 주어진 시간에 특정 개수의 포드 복제본이 실행되도록 합니다.
    - 배포
      - ReplicaSet 또는 개별 포드를 소유하고 관리합니다.
      - 배포에서 원하는 상태를 설명합니다. 그런 다음 배포는 클러스터의 실제 상태를 제어된 비율의 원하는 상태로 변경합니다.
    - ConfigMap
      - ConfigMap은 포드와 같은 기타 Kubernetes 객체에서 사용하는 키-값 쌍으로 기밀 데이터 이외의 데이터를 저장하는 API 객체입니다.
      - ConfigMaps를 사용하여 구성 데이터를 애플리케이션 코드와 분리하여 이동성의 모범 실무를 따르십시오.
    - 보안 정보
      - AWS 자격 증명과 같은 모든 기밀 데이터는 Kubernetes 보안 정보로 저장되어야 합니다.
      - 보안 정보는 민감한 정보에 대한 액세스를 제한합니다.
      - 원한다면 암호화를 켜서 보안을 강화할 수도 있습니다.
  - 포드 예약
    - Kubernetes 스케줄러로 포드를 예약할 수 있습니다. 스케줄러는 포드에 필요한 리소스를 확인하고 그 정보를 사용하여 스케줄링 결정에 영향을 줍니다.
    - 스케줄러는 일련의 필터를 실행하여 포드 배치에 부적격한 노드를 제외시킵니다.
  - 사용자 지정 리소스
    - Kubernetes가 정의하는 리소스(포드 및 배포) 외에도, Kubernetes API를 확장하고 사용자 지정 리소스를 생성할 수 있습니다.
    - 사용자 지정 리소스는 서비스 메시 객체와 같은 새 객체일 수도 있고 기본 Kubernetes 리소스의 조합일 수도 있습니다. 사용자 지정 리소스는 CRD(Custom Resource Definition)를 사용하여 생성됩니다.
  - 사용자 지정 리소스
    - Kubernetes가 정의하는 리소스(포드 및 배포) 외에도, Kubernetes API를 확장하고 사용자 지정 리소스를 생성할 수 있습니다.
    - 사용자 지정 리소스는 서비스 메시 객체와 같은 새 객체일 수도 있고 기본 Kubernetes 리소스의 조합일 수도 있습니다.
    - 사용자 지정 리소스는 CRD(Custom Resource Definition)를 사용하여 생성됩니다.
- Amazon EKS 가용성 및 API
  - Amazon EKS 제어 영역은 3개의 가용 영역에 걸친 최소 2개의 API 서버 노드와 3개의 etcd 노드로 구성됩니다.
  - Amazon EKS는 비정상 제어 영역 노드를 자동으로 탐지하여 교체하므로 Kubernetes 실행에 따른 운영 부담이 대폭 제거됩니다.
  - 이 기능을 사용하면 AWS 인프라를 관리하는 대신 애플리케이션 빌드에 집중할 수 있습니다.
  - Amazon EKS로 데이터 영역을 관리하는 이유는 무엇입니까?
    - 작업자 노드가 많은 복잡한 인프라를 관리하고 오토스케일링과 업데이트를 신경쓰는 것은 쉽지 않습니다. 또한 클러스터에 노드를 프로비저닝하는 여러 팀이 있을 수 있으며, 이들의 프로비저닝 방식은 각각 다를 수 있습니다.
    - 이러한 차이로 인해 표준화가 어려워집니다. Amazon EKS가 데이터 영역의 일부 또는 전부를 관리할 수 있도록 하면 인프라를 간소화하고 표준화를 유지할 수 있습니다.
    - 자체 관리형 노드
      - 제어 영역만 Amazon EKS에서 관리합니다. 데이터 영역 노드(프로비저닝, 업데이트, 모니터링 및 기타 작업)를 완벽하게 제어하고 관리할 수 있습니다.
    - 관리형 노드 그룹
      - 관리형 노드 그룹은 Amazon EKS API를 사용하여 Amazon EKS 클러스터용 컨테이너를 실행하는 Amazon Elastic Cloud Computing(Amazon EC2) 인스턴스를 시작하고 관리합니다. 관리형 노드 그룹은 자동으로 시작되고 관리되지만 EC2 인스턴스 및 Auto Scaling 그룹과 같이 AWS 계정에서 사용 중인 모든 리소스를 계속 볼 수 있습니다. 더 적은 작업으로 제어, 보안, 가시성을 모두 확보할 수 있습니다.
      - 프로비저닝
        - 관리형 노드 그룹을 단일 명령으로 배포합니다. 그러면 Amazon EKS가 최신 Amazon EKS 최적화 AMI(Amazon Machine Images)를 사용하여 노드를 생성합니다.
        - AWS 서비스는 이를 여러 가용 영역에 배포하고 Auto Scaling 그룹으로 지원합니다. 크기 조정 파라미터를 변경할 수 있습니다.
      - 관리
        - Amazon EKS는 관리형 노드 그룹의 상태 모니터링을 처리합니다.
        - Amazon EKS는 삭제 중이거나 연결할 수 없거나 사용할 수 없는 필수 리소스를 포함한 문제를 사용자에게 자동으로 알려줍니다.
        - Amazon EKS는 업데이트 문제, 한도 초과, 생성 또는 삭제 실패에 대해서도 알려줍니다. 노드 수준 Secure Shell(SSH) 액세스, 오픈 소스 로그 라우터 또는 Amazon CloudWatch에서 로그를 가져올 수도 있습니다. 또한 모든 관리형 노드 그룹 이벤트는 AWS CloudTrail에 기록됩니다.
      - 업데이트
        - 필요한 경우 단일 명령으로 관리형 노드 그룹을 업데이트할 수 있습니다. 그러면 Amazon EKS는 롤링 업데이트 시 노드 종료를 처리하고 Kubernetes 버전에 맞는 최신 AMI 버전으로 자동 업데이트합니다.
      - 크기 조정
        - 관리형 노드 그룹이 노드의 크기 조정을 처리합니다. 하지만 Kubernetes 레이블, AWS 태그, 노드 그룹의 크기와 같은 크기 조정 파라미터는 사용자가 여전히 제어할 수 있습니다.
      - 도구
        - eksctl을 사용하여 관리형 노드 그룹을 프로비저닝할 수 있습니다.
    - AWS FARGATE
      - 관리형 노드 그룹을 사용하면 인프라 관리에 쓰는 시간이 줄어듭니다. 하지만 애플리케이션 생성에만 집중하고 Amazon EKS가 데이터 영역을 완전히 관리하도록 하는 것이 좋습니다. 이는 Fargate에서 포드를 실행하면 가능합니다.
      - Fargate는 Kubernetes 데이터 영역의 전체 인프라를 관리합니다. 포드를 실행하는 데만 신경 쓰면 됩니다.
        - 네이티브 - Fargate는 네이티브 Kubernetes 포드를 실행합니다. AWS와 관련하여 아무것도 구성하거나 변경할 필요가 없습니다.
        - 적정 규모 – Fargate는 포드와 리소스에 필요한 리소스만 동적으로 프로비저닝합니다.
        - 빠르고 간편함 – Fargate는 신속하게 크기를 조정합니다. Cluster Autoscaler를 설치할 필요가 없습니다.
        - 최적화 – 포드가 실행될 때만 포드 비용을 지불하고, 포드 수준 청구를 확인할 수 있습니다.
- AWS EKS 구성
  - Amazon EKS에서 인증 및 권한 부여
    - AWS API 사용
      - aws eks create-cluster와 같은 AWS 명령의 경우에는 AWS IAM 서비스가 인증과 권한 부여를 모두 처리합니다.
      - Amazon EKS는 이에 따라 다른 AWS 서비스처럼 행동합니다.
    - KUBERNETES API 사용
      - kubectl get nodes와 같은 Kubernetes 명령의 경우 Amazon EKS는 Kubernetes 클러스터에 IAM 사용자 인증을 사용하지만, 권한 부여에는 기본 Kubernetes RBAC에 의존합니다. 인증을 위해 IAM 서비스를 사용하면 두 가지 기본적인 방식에서 클러스터 사용자 관리가 간소화됩니다.
        - IAM과 Amazon EKS 모두 AWS에서 관리하는 통합 서비스입니다.
        - 최종 사용자 인증을 제공하지 않는 Kubernetes의 문제를 해결합니다.
      - Amazon EKS 클러스터의 Kubernetes API와 상호 작용하기 위한 모든 권한은 기본 Kubernetes RBAC 시스템을 통해 관리됩니다.
  - 권한 구성
    - 클러스터 IAM 역할
      - Amazon EKS에서 클러스터를 관리하기 위해 사용자를 대신하여 AWS API를 호출할 수 있는 권한이 필요합니다.
      - 예를 들어 Amazon EKS에는 작업자 노드용 EC2 Auto Scaling을 관리할 권한이 필요합니다. 이 권한은 클러스터에 할당된 IAM 역할에 의해 제어됩니다. AWS는 IAM 정책에 이 역할에 대한 권장 권한을 제공합니다.
    - 노드 IAM 역할
      - Amazon EKS 작업자 노드의 kubelet 데몬은 사용자를 대신하여 AWS API를 호출합니다(예: Amazon Elastic Container Registry(Amazon ECR)에서 컨테이너 이미지 가져오기).
      - 작업자 노드는 작업자 노드에 할당된 IAM을 통해 이러한 API 호출에 대한 권한을 받습니다.
    - RBAC 사용자
      - Kubernetes 클러스터를 관리할 관리자는 Kubernetes API를 호출할 권한이 필요합니다. 이는 IAM 역할을 Kubernetes RBAC 사용자에게 매핑하여 이루어집니다. 클러스터를 생성하는 데 사용되는 IAM 역할에는 클러스터를 관리할 수 있는 전체 권한이 있으며, 일반적으로 필요한 것보다 더 많은 권한입니다.
      - 모범 실무는 클러스터 배포만을 위한 특정 IAM 역할을 생성하는 것입니다. 최소 권한의 원칙에 따라, IAM의 일상적인 운영을 위해 RBAC에서 더 제한적인 역할에 매핑하는 추가 원칙을 생성하십시오.
  - Amazon EKS 클러스터용 VPC는 세 가지 일반적인 설계 패턴 중 하나를 사용할 수 있습니다.
    - 퍼블릭 서브넷만
      - 이 VPC에는 리전의 다른 가용 영역에 배포되는 3개의 퍼블릭 서브넷이 있습니다.
      - 모든 작업자 노드에는 퍼블릭 IP 주소가 자동으로 할당되며 인터넷 게이트웨이를 통해 인터넷 트래픽을 주고받을 수 있습니다.
      - 모든 인바운드 트래픽을 거부하고 모든 아웃바운드 트래픽을 허용하는 보안 그룹이 배포됩니다.
    - 프라이빗 서브넷만
      - 이 VPC에는 리전의 다른 가용 영역에 배포되는 최대 3개의 퍼블릭 서브넷이 있습니다.
      - 모든 노드는 선택적으로 NAT(네트워크 주소 변환) 인스턴스 또는 NAT 게이트웨이를 통해 인터넷 트래픽을 보내고 받을 수 있습니다.
      - 모든 인바운드 트래픽을 거부하고 모든 아웃바운드 트래픽을 허용하는 보안 그룹이 배포됩니다.
    - 퍼블릭 및 프라이빗 서브넷
  - eksctl이 수행하는 작업의 개요
    - 클러스터 및 작업자 노드의 IAM 역할 생성
    - CIDR(클래스 없는 도메인 간 라우팅) 192.168.0.0/16을 사용하여 전용 VPC 생성
    - 클러스터 및 노드 그룹 생성
    - API 엔드포인트에 대한 액세스 구성
    - CoreDNS 설치
    - 클러스터의 kubeconfig 파일 작성
  - 수평 및 수직적 크기 조정
    - 수평적 크기 조정 : 수평으로 확장 가능한 시스템이란 컴퓨팅 리소스를 추가하거나 제거하여 용량을 늘리거나 줄일 수 있는 시스템입니다. 이 예에서는 수요가 급등할 때 더 많은 포드가 배포됩니다(스케일 아웃). 수요가 감소하면 포드가 제거됩니다(스케일 인).
    - 수직적 크기 조정 : 수직으로 확장 가능한 시스템은 더욱 빠른(또는 더욱 많은) CPU, 메모리 또는 스토리지와 같은 리소스를 컴퓨팅 리소스에 추가하여 성능을 높입니다.이 예에서는 수요가 급등할 때 포드의 크기(할당된 CPU 및 메모리 리소스)가 증가하고(스케일 업) 수요가 감소하면 크기가 줄어듭니다(스케일 다운).
  - 오토스케일링
    - Karpenter: Cluster Autoscaler의 대안
      - Karpenter는 노드 수명 주기 관리 솔루션입니다. 들어오는 포드를 관찰하고 상황에 적합한 인스턴스를 시작합니다.
      - 인스턴스 선택 결정은 의도 기반이며 리소스 요청 및 스케줄링 제약 조건을 비롯한 수신 포드 사양에 구속됩니다.
      - Karpenter가 배포되면
        - 예약되지 않은 포드에 대한 노드를 시작합니다.
        - 기존 노드를 대체하여 리소스 활용도를 높입니다.
        - 오래되었거나 더 이상 필요하지 않은 노드는 종료합니다.
        - 선점하기 전에 정상적으로 노드를 드레이닝합니다.
    - Horizontal Pod Autoscaler
      - Horizontal Pod Autoscaler(HPA)는 CPU 사용률 또는 Kubernetes 지표 서버를 통해 정의한 기타 지표를 기준으로 서비스를 자동으로 스케일 인 하거나 스케일 아웃 하는 Kubernetes 구성 요소입니다.
    - Kubernetes Vertical Pod Autoscaler(VPA)
      - 포드에 예약된 CPU 및 메모리를 자동으로 조정하여 애플리케이션의 크기를 적절히 조정할 수 있게 지원합니다. 이를 통해 클러스터 리소스 사용률을 개선하고 다른 포드를 위한 CPU 및 메모리를 확보할 수 있습니다.
  - EKS 통신 유형
    - Amazon EKS 환경에는 여러 통신 유형이 있습니다. 다음과 같은 통신 라인들이 있습니다.
    - 컨테이너 사이 포드 간 통신
      - 포드의 컨테이너는 Linux 네임스페이스를 공유하며 localhost로 서로 통신할 수 있습니다.
      - Kubernetes 네트워킹에서 컨테이너가 식별하는 IP 주소는 네트워크의 모든 엔터티에 대한 IP 주소와 동일합니다. 모든 컨테이너는 NAT 없이도 포드 내의 다른 모든 컨테이너와 통신할 수 있습니다.
    - 동일한 노드의 포드 간 또는 서로 다른 노드의 포드 간 통신
      - 각 포드에는 Linux 네임스페이스가 있지만 호스트 노드에도 Linux 네임스페이스가 있습니다. 각 네임스페이스에는 고유한 라우팅 테이블이 존재합니다.
      - 포드 네임스페이스와 호스트 네임스페이스는 Linux 가상 이더넷(veth) 디바이스를 이용해 연결됩니다. veth 한 쌍이 기본 호스트 네임스페이스와 Pod 네임스페이스 간에 터널을 만듭니다.
      - 호스트의 포드 간 통신은 이 veth 터널을 통해 발생합니다. 각 노드에 컨테이너의 네트워크 범위가 할당되고 각 포드는 동일한 호스트에 있는 컨테이너들이 통신할 수 있도록 해당 범위의 IP 주소를 가져옵니다.
    - 클러스터 외부에서의 인그레스 연결
      - 노드 간 통신을 간소화하기 위해 Amazon EKS는 Kubernetes용 Amazon VPC CNI 플러그 인을 통해 Amazon VPC 네트워킹을 Kubernetes에 통합합니다. CNI를 사용하면 Kubernetes 포드는 VPC 네트워크에서처럼 해당 포드 내에서 동일한 IP 주소를 가질 수 있습니다.
  - 수신(Ingress)
    - Kubernetes 수신 객체를 사용하면 사용하는 로드 밸런서의 수를 줄일 수 있습니다. 수신 객체는 클러스터 외부에 있는 HTTP 및 HTTPS 경로를 서비스에 노출하고 트래픽 규칙을 정의합니다.
  - AWS Load Balancer Controller
    - AWS Load Balancer Controller는 Kubernetes 클러스터용 ELB(Elastic Load Balancer(Elastic Load Balancing)를 관리하는 컨트롤러입니다.
    - 로드 밸런서는 Kubernetes 수신을 생성하는 경우 Application Load Balancer이거나 LoadBalancer 유형의 Kubernetes 서비스를 생성하는 경우 Network Load Balancer일 수 있습니다.
    - Application Load Balancer는 Open Systems Interconnection(OSI) 모델의 계층 7(예: HTTP 또는 HTTPS)에서의 애플리케이션 트래픽을 밸런싱하는 반면,
    - Network Load Balancer는 계층 4[예: Transmission Control Protocol(TCP), User Datagram Protocol(UDP) 등]에서의 네트워크 트래픽을 밸런싱합니다.
    - Application Load Balancer는 노드 또는 Fargate에 배포된 포드와 함께 사용될 수 있습니다.
    - Application Load Balancer는 퍼블릭 또는 프라이빗 서브넷에 배포될 수 있습니다.
    - Network Load Balancer는 Amazon EC2 IP및 인스턴스 대상에 배포된 포드나 Fargate IP 대상에 네트워크 트래픽을 로드 밸런싱할 수 있습니다.
- EKS 다른 서비스와 통합
  - Kubernetes 영구 스토리지
    - 포드 수명 주기와 상관 없이 데이터 지속성이 필요한 애플리케이션 워크로드에는 두 가지 이상의 Kubernetes 객체와 영구 볼륨(PV) 및 영구 볼륨 클레임(PVC)이 필요합니다.
    - PV는 임시 볼륨이지만 개별 포드에 독립적인 수명 주기를 가진다는 점을 상기시킵니다.
    - PVC는 클러스터 사용자에 의한 스토리지에 대한 요청으로, 요청에 스토리지 양, 스토리지 액세스 종류 및 스토리지 성능에 대한 세부정보가 포함됩니다.
  - AMAZON EBS 사용
    - 클러스터 사용자가 필수 파라미터와 함께 PVC를 제출할 때 Amazon EBS 스토리지 클래스가 EBS CSI 드라이버에서 호출되어 PVC 요청당 스토리지를 할당합니다.
    - EBS CSI 드라이버는 EBS 볼륨을 생성하고 볼륨을 지정된 클러스터 노드에 연결하는 데 필요한 AWS API를 호출합니다. 연결되면 영구 볼륨이 PVC에 할당됩니다.
    - Amazon EBS CSI 드라이버를 구성하여 볼륨 크기 조정, 볼륨 스냅샷 생성 등을 포함한 여러 가지 Amazon EBS 기능을 사용할 수 있습니다.
  - AMAZON EFS 사용
    - Amazon EFS에서 지원하는 Kubernetes 스토리지 클래스는 Amazon EFS CSI 드라이버에 기존 파일 시스템에 대한 액세스 포인트를 생성하기 위한 적절한 AWS API를 호출할 것을 지시합니다.
    - PVC가 생성되면 동적으로 프로비저닝된 PV가 Amazon EFS 파일 시스템에 액세스하는 데 해당 액세스 포인트를 사용한 다음 PVC로 바인딩됩니다.
  - AWS App Mesh
    - App Mesh는 서비스 모니터링 및 제어를 일련화하는 서비스입니다.
    - App Mesh는 서비스의 통신 방식을 표준화하여 사용자에게 엔드 투 엔드 가시성을 제공하고 애플리케이션에 대한 고가용성을 보장합니다.
    - App Mesh는 애플리케이션의 모든 서비스에 일관된 가시성 및 네트워크 트래픽 제어 기능을 제공합니다.
- Amazon EKS 클러스터 업그레이드
  - 새 Kubernetes 버전으로 업그레이드할지 여부를 결정할 때 다음 사항을 고려하십시오.
    - Kubernetes의 다음 버전으로 업그레이드할 때 이점은 무엇입니까?
    - Kubernetes 버전의 업그레이드 완료를 어느 팀에서 담당합니까?
    - 노드 및 추가 기능과 같은 다운스트림 구성 요소 중에서 함께 업그레이드해야 하는 것은 무엇입니까?
    - 다운스트림 종속성을 어떤 순서로 업그레이드해야 합니까?
    - 업그레이드가 진행되는 동안 애플리케이션에 어떤 영향을 줍니까?
    - 에코시스템 내 애플리케이션 중 Kubernetes API를 사용하는 것이 있습니까? 이 애플리케이션에 대한 영향 분석을 수행하는 것도 고려해봅니다.
- Amazon EKS 업그레이드 프로세스
  - 클러스터 업그레이드 중 발생하는 이벤트 순서
    - API 서버 노드
      - 업그레이드 시 Amazon EKS는 업그레이드된 Kubernetes 버전으로 새 API 서버 노드를 시작하여 기존 노드를 대체합니다.
      - Amazon EKS는 이러한 새 노드의 네트워크 트래픽에 대한 표준 인프라 및 준비 상태 확인을 수행하여 예상대로 작동하는지 확인합니다.
    - 자동 롤백
      - 이러한 검사 중 하나라도 실패할 경우 Amazon EKS가 인프라 배포를 되돌리고, 클러스터는 이전 Kubernetes 버전으로 남아 있게 됩니다.
      - 실행 중인 애플리케이션은 영향을 받지 않으며 클러스터는 복구할 수 없는 상태로 남아 있지 않습니다. Amazon EKS는 모든 관리형 클러스터를 정기적으로 백업하며 필요한 경우 클러스터를 복구하는 메커니즘이 존재합니다.
    - 경미한 서비스 중단 발생 가능
      - 클러스터를 업그레이드하기 위해 Amazon EKS는 클러스터를 생성할 때 제공된 서브넷에 사용 가능한 IP 주소 2~3개가 필요합니다. 이 서브넷에 사용 가능한 IP 주소가 없으면 업그레이드가 실패할 수 있습니다.
      - 클러스터 생성 시 제공된 서브넷 또는 보안 그룹이 삭제된 경우, 클러스터 업그레이드 프로세스가 실패할 수 있습니다.
    - 노드 및 Kubernetes 추가 기능 업그레이드
      - Amazon EKS는 클러스터의 제어 영역을 업그레이드할 때 실행 중인 애플리케이션, 클러스터 작업자 노드, Amazon EKS 추가 기능 또는 Kubernetes 추가 기능을 수정하지 않습니다.
      - 클러스터 업그레이드 프로세스를 완료하는 데 필요한 작업을 수행해야 합니다.
  - Amazon EKS는 관리형 노드 그룹 버전을 업그레이드할 때 다음 작업을 수행합니다.
    - Amazon EKS는 사용자의 노드 그룹과 연결된 EC2 Auto Scaling 그룹을 위한 새로운 Amazon EC2 시작 템플릿 버전을 생성합니다. 이 신규 템플릿은 업데이트를 위해 대상 AMI를 사용합니다.
    - 새 AMI에 최신 시작 템플릿을 사용하도록 EC2 Auto Scaling 그룹이 업그레이드됩니다.
    - 기존 EC2 인스턴스와 함께 새 EC2 인스턴스가 생성되도록 EC2 Auto Scaling 그룹의 최대 크기와 원하는 크기가 증분됩니다.
    - EC2 Auto Scaling 그룹이 더 커진 노드 그룹의 크기를 충족하기 위해 새 AMI로 새 인스턴스를 시작합니다.
    - Amazon EKS가 노드 그룹 내 노드들의 eks.amazonaws.com/nodegroup-image 레이블을 점검합니다. Amazon EKS는 노드 그룹에서 최신 AMI ID로 레이블이 지정되지 않은 모든 노드를 코든합니다. 이렇게 하면 이전에 실패한 업그레이드에서 이미 업그레이드된 노드가 코든되지 않습니다.
    - Amazon EKS가 노드 그룹에서 노드를 임의로 선택하고 EC2 Auto Scaling 그룹에 종료 신호를 보냅니다. 그다음 Amazon EKS는 노드에서 포드를 드레인하라는 신호를 보냅니다. 노드가 드레인되면 종료됩니다. 모든 노드가 새 AMI 버전을 사용할 때까지 이 절차가 반복됩니다.
    - EC2 Auto Scaling 그룹의 최대 크기와 원하는 크기가 1씩 감소하여 업그레이드 이전의 값으로 돌아갑니다.
    - 업데이트 전략의 두가지 옵션
      - 롤링 업데이트 – 이 옵션은 클러스터에 대한 PodDisruptionBudget에 따릅니다. PodDisruptionBudget 문제 때문에 Amazon EKS가 이 노드 그룹에서 실행되고 있는 Pod를 정상적으로 드레인할 수 없는 경우, 업데이트가 실패합니다.
      - 강제 업데이트 – 이 옵션은 PodDisruptionBudgets를 준수하지 않습니다. 노드를 강제로 다시 시작합니다.
  - 자체 관리형 작업자 노드
    - 자체 관리형 노드 그룹을 업그레이드하고 있다면 두 가지 전략을 고려할 수 있습니다.
      - 새 노드 그룹으로 마이그레이션 – 새 노드 그룹을 생성하고 포드를 해당 그룹으로 마이그레이션합니다.
      - 기존 자체 관리형 노드 그룹업데이트 – 기존 노드 그룹에 대한 CloudFormation 스택을 업데이트하여 새 AMI를 사용합니다.

# Getting Started with DevOps on AWS
- DevOps
  - DevOps란?
    - DevOps는 애플리케이션과 서비스를 빠른 속도로 제공할 수 있도록 조직의 역량을 향상시키는 문화 철학, 방식 및 도구의 조합입니다.
    - 기존의 소프트웨어 개발 및 인프라 관리 프로세스를 사용하는 조직보다 제품을 더 빠르게 혁신하고 개선할 수 있습니다.
    - 장벽을 제거하고 포괄적인 책임 공유 실현하기 위한 문화적 철학
    - 높은 속도와 품질로 사람들이 작업하는 방식을 간소화하도록 개발된 프로세스
    - 프로세스에 맞게 조정하고 반복 가능한 태스크를 자동화하여 릴리스 프로세스의 효율성과 애플리케이션의 안정성을 높이는 도구
  - 기존 개발 방식의 문제점
    - 폭포형 개발 프로젝트는 느리고 반복이 불가능하며 변화를 수용하기가 어렵고 릴리스 주기가 깁니다.
      - 몇 가지 이유
        - 요구 사항이 엄격하고 프로젝트 시작 시 설정되며 변경되지 않습니다.
        - 개발 단계가 사일로화되어 있으며, 각 단계는 이전 단계가 끝난 후 시작됩니다. 각 단계는 고도로 전문화된 팀이 지원합니다. 한 단계에서 다른 단계로 넘기는 시간이 길기 때문에 팀이 도구를 전환하고 불완전하거나 모호한 정보를 명확히 하는 데 시간을 할애해야 하는 경우가 많습니다.
        - 테스트 및 보안은 구현 후에 이루어지고, 시정 조치는 사후 대응적이고 비용이 많이 듭니다.
    - 모놀리식 애플리케이션은 다음과 같은 이유로 인해 업데이트하고 배포하기가 어렵습니다.
      - 하나의 유닛으로 개발 및 배포되므로 변경 사항이 발생하면 전체 애플리케이션을 다시 배포해야 합니다.
      - 애플리케이션의 규모가 어느 정도 크면 개발자가 전체 애플리케이션을 이해하는 데 어려움을 겪기 때문에 유지 관리가 문제가 됩니다.
      - 단일 개발 스택을 사용하여 구현되므로 기술을 변경하기가 어렵고 비용이 많이 듭니다.
    - 애플리케이션 수명 주기 전반에 걸친 수작업 프로세스가 느리고 일관성이 없으며 오류가 발생하기 쉽습니다. 예를 들어 인프라를 수동으로 설정하고 구성하는 데 시간이 많이 걸립니다. 이 프로세스를 수동으로 반복할 경우 특정 단계가 누락되지 않는다는 보장이 없습니다. 또 다른 예는 코드를 푸시하기 전에 철저히 테스트했는지 개발자에게 알려주는 것입니다. 아무리 좋게 봐주더라도, 이 수동 프로세스는 느리고 누군가가 한두 가지 테스트를 잊어버릴 가능성이 늘 존재합니다.
    - 소프트웨어 개발 수명 주기를 지원하는 팀은 전통적으로 사일로화되어 있습니다. 비즈니스, 개발, 품질 보증, 전문가, 유지 보수 및 운영과 같은 팀이 서로 분리되어 있으며 일정에 따른 엄격한 핸드오프를 필요로 합니다. 이들 팀은 애플리케이션을 제공하고 지원한다는 공통된 목표를 가지고 있긴 하지만, 자체적인 우선 순위, 도구 및 프로세스도 갖추고 있습니다. 프로젝트 멤버가 서로 다른 부서에 보고하고 다른 목표를 가진 경우 효율성을 실현하기가 어렵습니다.
- DEVOPS 방법론
  - DevOps 문화를 실현하는 데 도움이 되는 7가지 핵심 원칙
    - 고도의 협업 환경 구축
      - DevOps는 개발 및 운영을 통합하여 사일로를 없애고 목표를 조정하며 공동의 목표를 달성합니다.
      - 전체 팀(개발, 테스트, 보안, 운영 등)이 출시된 소프트웨어에 대한 전반적인 소유권을 보유합니다.
      - 전체 팀이 협력하여 개발자의 생산성과 운영의 안정성을 최적화합니다. 팀들은 서로의 경험을 통해 배우고, 우려 사항과 관점에 귀를 기울이고, 프로세스를 간소화하여 필요한 결과를 얻습니다.
      - 이러한 향상된 가시성을 통해 프로세스를 통합하고 지속적으로 개선하여 비즈니스 목표를 달성할 수 있습니다.
      - 협업은 각 팀 구성원의 노력을 소중하게 여기는 깊은 신뢰의 문화를 조성하고 팀과 조직 전체에 지식과 모범 사례를 전달합니다.
    - 가능한 경우 자동화
      - DevOps 방식에서는 반복 가능한 작업이 자동화되므로 팀이 혁신에 집중할 수 있습니다.
      - 자동화는 신속한 개발, 테스트 및 배포를 위한 수단을 제공합니다. 올바른 도구 및 서비스를 사용하여 코드 통합, 검토, 테스트, 보안, 배포, 모니터링 등 모든 단계에서 자동화 기회를 파악합니다.
      - 예를 들어 사전 정의된 환경 또는 승인된 환경에 Infrastructure as Code(IaC)를 사용할 수 있으며, 버전을 관리하면서 반복 가능하고 일관된 환경을 구축할 수 있습니다.
      - 규제 검사를 정의하고 릴리스 파이프라인의 일부로서 지속적으로 실행되는 테스트에 반영할 수도 있습니다.
    - 고객 요구 사항에 집중
      - 고객 최우선의 사고 방식은 개발의 핵심 요소입니다.
      - 예를 들어 피드백 루프를 통해 DevOps 팀은 고객과 꾸준히 접촉하면서 고객의 요구를 충족하는 소프트웨어를 개발합니다.
      - 마이크로서비스 아키텍처를 사용하면 방향을 신속하게 전환하고 이러한 요구 사항에 맞게 작업을 조정할 수 있습니다.
      - 간소화된 프로세스와 자동화는 요청된 업데이트를 더 빠르게 제공하고 높은 고객 만족도를 유지합니다. 모니터링을 통해 팀은 애플리케이션의 성공 여부를 판단하고 고객 중심의 노력을 지속적으로 조정할 수 있습니다.
    - 소규모 개발 및 빈번한 릴리스
      - 애플리케이션은 더 이상 엄격한 개발, 테스트 및 배포 방식을 적용하는 하나의 모놀리식 시스템으로 개발되지 않습니다.
      - 애플리케이션 아키텍처는 소규모의 소결합된 구성 요소로 설계됩니다. 이전 버전과의 호환성 또는 변경 관리와 같은 포괄적 정책이 적용되어 개발 과정에 거버넌스를 제공합니다.
      - 팀은 필요한 시스템 아키텍처에 맞추어 구성됩니다. 팀은 작업에 대한 책임 의식을 가집니다.
      - 소규모의 빈번한 코드 릴리스와 같은 최신 개발 방식을 도입하면 팀이 고객의 요구와 비즈니스 목표에 빠르게 대응할 수 있는 민첩성을 확보할 수 있습니다.
    - 모든 단계에 보안 포함
      - 지속적 전달을 지원하려면 릴리스 이전에 수행된 작업이 아니라 애플리케이션 수명 주기의 모든 단계에서 반복적이고 점진적이며 자동화된 보안이 적용되어야 합니다.
      - 애플리케이션 수명 주기의 각 단계에 보안을 포함하도록 개발 및 운영 팀을 교육합니다. 이렇게 하면 잠재적인 취약성이 중대한 문제가 되고 수정 비용이 더 많이 필요해지기 전에 식별하고 해결할 수 있습니다.
      - 예를 들어 하드 코딩된 액세스 키 또는 제한된 포트 사용을 검사하는 보안 테스트를 포함할 수 있습니다.
    - 지속적인 실험과 학습
      - 문의, 혁신, 학습 및 멘토링을 장려하고 DevOps 프로세스에 반영합니다.
      - 팀이 혁신을 추구하며, 진행 상황이 모니터링됩니다. 혁신 과정에서는 실패가 있기 마련입니다.
      - 경영진은 실패를 받아들이고 팀이 실패를 학습 기회로 삼도록 장려합니다.
      - 예를 들어 팀은 DevOps 도구를 사용하여 필요에 따라 환경을 스핀업하여 새로운 기술로 고객의 요구 사항을 지원하는 실험과 혁신을 지원할 수 있습니다.
    - 지속적인 개선
      - 신중하게 정의된 지표는 팀이 진행 상황을 모니터링하고 프로세스와 도구를 평가하며 공통의 목표와 지속적인 개선을 이루어나가는 데 도움이 됩니다.
      - 예를 들어, 팀이 처리량과 같은 개발 성능 측정 결과를 개선하기 위해 노력할 수 있습니다. 또한 안정성을 높이고 평균 서비스 복원 시간을 줄이기 위해 노력합니다.
      - 적절한 모니터링 도구를 사용하여 일반적인 동작에 대한 애플리케이션 벤치마크를 설정하고, 변동을 지속적으로 모니터링할 수 있습니다.
  - DevOps 작업을 지원하는 데 필요한 일반적인 도구 범주
    - 클라우드
      - 개발 팀은 안정적이고 안전한 애플리케이션을 신속하게 혁신하고 제공해야 합니다.
      - 팀은 애플리케이션 개발 노력을 지원할 다양한 기술을 활용하는 데 있어 클라우드 플랫폼 공급자와 클라우드 컴퓨팅 리소스에 의존합니다.
      - 팀은 물리적 데이터 센터와 서버를 구매, 소유 및 유지 관리하는 대신 AWS와 같은 클라우드 공급자를 사용하여 온디맨드 방식으로 환경을 프로비저닝합니다.
    - 개발
      - DevOps 팀은 팀원들과 지속적으로 협업해야 합니다.
      - IDE(통합 개발 환경)는 애플리케이션에 대한 코드를 작성, 실행 및 디버깅하는 데 도움이 됩니다.
      - SDK(소프트웨어 개발 키트)는 프로그래머가 특정 플랫폼에 대한 애플리케이션을 개발할 수 있도록 하는 도구 세트입니다.
      - 소스 코드 리포지토리 또는 버전 관리 시스템은 프로젝트의 파일을 저장합니다.
      - 필요에 따라 문서 및 코드에 액세스하거나, 개정 기록을 보거나, 시간에 따른 변경 내용을 비교하거나, 이전 버전으로 되돌릴 수 있습니다.
      - 예
        - IDE: AWS Cloud9, IntelliJ, Eclipse, Visual Studio Code
        - SDK: AWS SDK for Java, iPhone SDK
        - 소스 코드 리포지토리: GitHub, AWS CodeCommit
    - CI/CD
      - 지속적인 테스트, 지속적 통합(CI), 지속적 전달/배포(CD) 등의 방식은 모든 개발 단계에서 원활한 연속성을 제공하는 도구를 통해 지원됩니다.
      - CI/CD 도구는 지속적으로 통합된 코드를 자동화하여 팀이 코드를 개발하고, 표준을 준수하며, 테스트를 더 자주 실행하고, 다양한 테스트 환경으로 코드를 승격하고, 제품을 인프라에 반복적, 안정적으로 배포할 수 있습니다.
      - CI/CD 도구는 애플리케이션 개발 및 배포 프로세스에 민첩성을 제공하는 동시에, 지속적으로 피드백을 제공하고 적절한 팀에게 모든 문제를 경고하는 데 도움이 되어야 합니다.
      - 예
        - 빌드 도구: Jenkins, Travis CI, AWS CodeBuild
        - 소스 제어 도구, 리포지토리: Git, AWS CodeCommit
        - 배포 도구: AWS CodeDeploy, AWS CloudFormation
        - 파이프라인 자동화 도구: AWS CodePipeline, Jenkins, GitLab
    - 인프라 자동화
      - 제약 조건을 포함하여 인프라를 프로그래밍 방식으로 정의하여 환경(개발 샌드박스, 테스트, 스테이징, 프로덕션)을 반복적으로 일관되게 프로비저닝합니다.
      - 템플릿을 사용하여 컴퓨팅 서비스, 권한, 종속성 등을 배포할 수 있습니다. 규칙을 구성하고 업데이트 적용을 자동화할 수 있습니다.
      - 예
        - 인프라 자동화 도구: AWS CloudFormation, Terraform, AWS Elastic Beanstalk
        - 구성 관리 도구: Chef, Puppet, AWS OpsWorks
    - 컨테이너 및 서버리스
      - 개발자는 컨테이너 및 서버리스 컴퓨팅 서비스를 통해 호스트 환경의 세부 정보가 아닌 애플리케이션에 집중할 수 있습니다.
        - 컨테이너는 애플리케이션을 실행하는 데 필요한 코드, 구성 설정 및 종속성을 패키징합니다. 이렇게 하면 애플리케이션을 이동하여 모든 서버에서 실행할 수 있습니다.
        - 컨테이너는 가상 머신과 유사하지만 운영 체제(OS) 수준에서 가상화되기 때문에 더 가볍습니다. 컨테이너는 마이크로서비스에서 레거시 대형 애플리케이션에 이르기까지 모든 요소를 실행합니다.
        - 여러 환경에 애플리케이션을 구축, 테스트 및 배포하는 방식을 간소화합니다. 보안 정책을 컨테이너 수준에서 구현할 수 있기 때문에 배포된 애플리케이션의 보안이 강화됩니다.
        - 컨테이너의 경우 개별 컨테이너의 작업을 관리하거나 예약하기 위한 컨테이너 오케스트레이션이 필요합니다.
      - 서버리스 컴퓨팅 서비스는 코드를 빌드 및 실행하고, AWS와 같은 서비스의 클라우드 공급자가 인프라 오버헤드를 관리할 수 있게 해주는 서비스입니다.
      - 예
        - 서버리스 서비스: AWS Lambda, AWS Fargate
        - 컨테이너 서비스
          - 런타임: 도커, 컨테이너화됨
          - 오케스트레이션: Amazon Elastic Container Service(Amazon ECS), Kubernetes, Amazon Elastic Kubernetes Service(Amazon EKS)
    - 모니터링 및 관측성
      - 모니터링 및 관측성은 DevOps의 핵심 측면이므로 문제가 발생하기 전에 사전 예방할 수 있습니다.
      - 도구를 사용하여 애플리케이션의 상태 및 성능에 대한 지표를 수집할 수 있습니다. 배포 빈도를 캡처하고 성공하거나 실패한 배포, 애플리케이션 사용 트래픽 등을 식별할 수 있습니다.
      - 도구를 사용하면 분산 시스템을 통해 엔드 투 엔드 요청 및 트랜잭션 흐름을 추적할 수 있습니다.
      - 도구를 사용하면 로그, 지표 및 추적을 시각화하고 분석하여 시스템의 상태, 성능 및 가용성에 대한 새로운 인사이트를 얻을 수 있습니다.
      - 인사이트를 통해 프로세스를 간소화하고 시스템 성능을 개선하며 가동 중지 시간을 줄일 수 있습니다.
      - 예: AWS X-Ray, Amazon CloudWatch, AWS Config, AWS CloudTrail
- AWS DEVOPS 도구
  - AWS CODEPIPELINE
    - AWS CodePipeline은 소프트웨어를 릴리스하는 데 필요한 단계를 모델링, 시각화 및 자동화할 수 있게 해주는 지속적 전달 서비스입니다.
    - CodePipeline을 사용하면 다음을 수행할 수 있습니다.
      - 파이프라인을 캡처 및 시각화하고, 실행하며, 실시간 상태를 확인하고, 실패한 작업을 다시 시도합니다.
      - 릴리스 프로세스를 자동화하여 인적 오류를 없애고 제공 속도를 높이고 릴리스 품질을 개선합니다.
      - 릴리스의 일관성을 유지합니다.
      - 소스 통합, 빌드 및 배포 도구를 통합합니다.
      - 파이프라인 기록 세부 정보를 봅니다.
      - 서드 파티 및 AWS 도구와 통합하여 코드 변경 알림을 받을 때 코드를 빌드, 테스트 및 배포할 수 있습니다.
    - 모니터링
      - 다양한 방법으로 파이프라인을 모니터링하여 성능, 안정성 및 가용성을 보장하고 개선 방법을 찾을 수 있습니다.
      - AWS CodePipeline 콘솔 또는 CLI(명령줄 인터페이스)에서 직접 파이프라인을 모니터링하거나, Amazon EventBridge 또는 AWS CloudTrail을 사용할 수 있습니다.
    - 보안
      - CodePipeline은 리소스 수준 권한을 지원하므로 파이프라인에서 수행 가능한 작업을 지정할 수 있습니다.
      - 일부 사용자에게는 파이프라인에 대한 읽기 전용 액세스 권한을 부여하고, 다른 사용자에게는 단계 내의 특정 단계 또는 작업에 대한 액세스 권한을 부여할 수 있습니다.
    - 작동 방식
      - CodePipeline을 사용하여 여러 단계와 작업으로 릴리스 프로세스를 모델링합니다.
      - 작업은 순서대로 또는 서로 병렬로 실행할 수 있는 태스크입니다. 작업은 작업을 실행하는 서비스 공급자와 연결되거나, 사용자 개입을 필요로 할 수 있습니다. 서비스 공급자는 AWS 서비스(예: CodeBuild, Amazon Simple Storage Service(Amazon S3), AWS Lambda, AWS CloudFormation)이거나 서드 파티 서비스(예: Jenkins, TeamCity)일 수 있습니다.
      - 작업 유형
        - 소스(소스가 저장되는 위치)
        - 빌드(애플리케이션을 빌드하는 방법)
        - 테스트(애플리케이션을 테스트하는 방법)
        - 배포(애플리케이션을 배포하는 방법)
        - 승인(수동 승인 및 알림)
        - 호출(사용자 지정 함수 호출)
  - AWS CODECOMMIT
    - AWS CodeCommit은 안전한 Git 기반 리포지토리를 호스팅하는 완전관리형 소스 제어 서비스입니다. 리포지토리는 CodeCommit의 기본 버전 관리 객체이며 프로젝트 파일과 소스 코드를 저장합니다.
    - CodeCommit를 사용하면 다음을 수행할 수 있습니다.
      - 코드를 저장하는 데 필요한 하드웨어 및 소프트웨어를 관리하는 데 따른 관리 오버헤드를 없앨 수 있습니다. CodeCommit는 가용성이 높으며 저장할 수 있는 파일의 형식이나 크기에 제한이 없는 완전관리형 서비스입니다.
      - 이미 익숙한 Git 명령을 사용하여 코드로 팀과 협업합니다. CodeCommit은 많은 수의 파일, 코드 분기 및 긴 개정 기록을 처리 할 수 있는 안전한 GIT 기반 리포지토리입니다.
      - CodeCommit를 다른 AWS 서비스, IDE 및 서드 파티 소프트웨어(예: Jira)와 통합하여 기존 워크플로를 개선합니다.
    - 모니터링
      - 분기 생성 또는 커밋 시점과 같은 이벤트를 기반으로 알림을 생성하고 작업을 트리거할 수 있습니다.
    - 보안
      - 보안 측면에서 보면, 리포지토리에 대한 액세스는 정책 및 사용자 계정으로 관리됩니다.
      - 리포지토리 버전은 클라우드에서 확인할 수 있으며, HTTPS 또는 Secure Shell(SSH)을 통해 평가할 수 있습니다. 데이터는 암호화된 상태로 저장 및 전송됩니다.
    - 작동 방식
      - CodeCommit에서 리포지토리를 생성합니다. 사용자가 자신의 환경에 복제하여 자체 리포지토리 복사본을 만듭니다. 변경 후에는 해당 변경 사항을 CodeCommit 리포지토리로 다시 푸시합니다.
      - CodeCommit 리포지토리는 Git 소스 제어를 통해 관리됩니다. Git 명령(예: git add, git push, git branch)을 사용하여 코드 작업을 수행하고 협업할 수 있습니다.
      - 파이프라인의 일부인 경우 CodeCommit는 구성된 CodeCommit 리포지토리 및 분기에서 새 코드가 변경되면 파이프라인을 시작할 수 있습니다.
  - AWS CODEBUILD
    - AWS CodeBuild는 소스 코드를 자동으로 컴파일하고 테스트를 실행하며 소프트웨어 패키지를 생성하는 완전관리형 구축 서비스입니다.
    - CodeBuild를 사용하면 다음을 수행할 수 있습니다.
      - CodeBuild가 완벽하게 관리되므로 자체 빌드 서버를 설정하고, 패칭하고, 업데이트하고 관리할 필요성을 없앱니다.
      - 자동으로 소스 코드를 컴파일하고 테스트를 실행하고 빌드 아티팩트를 생성합니다.
      - 빌드의 각 단계에서 실행할 빌드 명령을 지정합니다.
      - 여러 빌드를 동시에 처리합니다. 예를 들어 개발자는 코드를 지속적으로 빌드 및 테스트하고 오류를 조기에 포착하여 수정할 수 있습니다.
      - 사전 구성된 기본 빌드 환경(예: .NET Core, Java, Ruby, Python, Go, NodeJS, Android 및 도커)을 활용합니다. 빌드 환경에는 운영 체제, 프로그래밍 언어 런타임 및 빌드 도구(예: Apache Maven, Gradle)가 포함되어 있습니다. 도커 이미지를 사용하여 필요에 맞는 사용자 지정 빌드 환경을 제공할 수도 있습니다.
      - CodeCommit, Amazon S3, GitHub, GitHub Enterprise 및 Bitbucket에서 소스 코드를 가져옵니다.
      - 빌드 프로세스를 간소화하기 위해 CodeBuild를 Jenkins와 통합합니다.
    - 모니터링
      - CodeBuild 콘솔, CloudWatch Logs 및 기타 여러 가지 방법을 통해 빌드를 모니터링할 수 있습니다.
    - 보안
      - 빌드 아티팩트가 암호화되며, AWS Identity and Access Management(IAM) 정책의 리소스 수준 권한을 통해 빌드 프로젝트에 대한 액세스를 제어할 수 있습니다.
    - 작동 방식
      - CodeBuild는 빌드 프로젝트에서 제공하는 정보를 사용하여 빌드 환경(빌드 시에 새로 생성되는 프로비저닝된 도커 컨테이너)을 만든 다음 빌드를 실행합니다. 다음은 빌드 시에 CodeBuild가 수행하는 단계에 대한 개요입니다.
        - CodeBuild는 빌드 프로젝트를 사용하여 빌드를 실행합니다. 빌드 프로젝트에는 소스 리포지토리 위치, 런타임 환경, 빌드 명령, 빌드 출력을 저장하는 위치 등 빌드를 실행하는 데 필요한 정보가 포함되어 있습니다. CodeBuild에 액세스하려면 AWS 관리 콘솔, AWS 명령줄 인터페이스(AWS CLI), AWS SDK 또는 CodePipeline을 사용합니다.
        - CodeBuild는 빌드 프로젝트를 사용하여 빌드 환경을 만듭니다.
        - CodeBuild는 코드를 다운로드하고, 빌드 사양(buildspec) 파일을 사용하여 빌드를 실행합니다. buildspec은 빌드의 각 단계(예: 도구 패키지 설치, 테스트 실행 또는 코드 패키징)에서 실행되는 빌드 명령과 관련 설정의 모음입니다.
        - 모든 빌드 출력은 Amazon S3 버킷에 업로드되며, 알림을 구성할 수 있습니다.
        - 빌드 출력은 서비스 콘솔과 CloudWatch Logs로 스트리밍됩니다.
        - CloudWatch 또는 기타 서비스를 통해 빌드 진행률을 모니터링합니다.
  - AWS CODEDEPLOY
    - AWS CodeDeploy는 소프트웨어 배포를 자동화하여 안정적으로 신속하게 배포할 수 있도록 하는 완전관리형 서비스입니다. Amazon Elastic Compute Cloud(Amazon EC2), AWS Fargate, AWS Lambda 또는 온프레미스 서버를 비롯하여 다양한 컴퓨팅 서비스로의 코드 배포를 자동화합니다.
    - CodeDeploy를 사용하면 다음을 수행할 수 있습니다.
      - 서버, 서버리스 또는 컨테이너 애플리케이션을 배포합니다.
      - 배포를 자동화하고 오류가 발생하기 쉬운 수작업의 필요성을 배제합니다. CodeDeploy를 사용하면 새로운 기능과 업데이트를 안정적으로 신속하게 릴리스할 수 있습니다.
      - AWS Lambda, Amazon ECS, Amazon EC2, 온프레미스 등 다양한 컴퓨팅 플랫폼에 배포합니다. Amazon EC2 Auto Scaling 그룹에 배포하도록 CodeDeploy를 구성할 수도 있습니다. 그러면 트래픽이 전송되기 전에 환경을 준비할 수 있습니다.
      - 서비스가 확장됨에 따라, 요구 사항에 맞추어 하나 또는 여러 개의 인스턴스에 동시에 배포합니다.
      - 업데이트를 기존 인스턴스에 적용할지 아니면 이전 환경을 대체할 새로 프로비저닝된 환경에 적용할지를 지정하여 애플리케이션의 프로덕션 가동 중단 시간을 최소화합니다. 이전 버전에서 새 버전으로의 트래픽 이동을 처리하는 방법도 제어할 수 있습니다. 예를 들어 애플리케이션에서 배포 그룹의 인스턴스 중 50% 이상을 가동하고 트래픽을 처리해야 하는 경우, 배포 구성에서 이를 지정하여 배포로 인해 가동 중지 시간이 발생하지 않도록 할 수 있습니다.
      - 실패한 배포를 자동으로(또는 사용자가 개입하여) 중지하고 배포를 이전 버전으로 롤백합니다.
    - 모니터링
      - AWS는 CloudWatch 경보, CodeDeploy 콘솔 등 CodeDeploy를 모니터링하는 데 사용할 수 있는 다양한 도구를 제공합니다.
    - 보안
      - 보안 및 규정 준수 목표를 충족하도록 CodeDeploy를 구성할 수 있습니다.
    - 작동 방식
      - 적절한 컴퓨팅 리소스로의 배포를 자동화하려면, CodeDeploy가 복사할 파일, 실행할 스크립트 및 배포할 위치를 알아야 합니다.
      - 애플리케이션의 개념은 CodeDeploy에서 배포할 대상(적절한 코드 개정 버전), 배포할 위치(배포 그룹) 및 배포 방법(배포 구성)을 인식하도록 하는 데 사용됩니다.
      - 코드
        - 코드의 올바른 버전(개정 버전)을 식별합니다.
        - 코드를 사용하여 각 배포를 관리하는 데 사용되는 애플리케이션 사양 파일(AppSpec 파일)을 제공합니다. 배포하는 동안 CodeDeploy는 애플리케이션 소스의 루트 디렉터리에서 AppSpec 파일을 찾습니다.
        - AppSpec 파일은 코드를 복사할 위치와 실행 방법을 지정합니다. 예를 들어 애플리케이션이 이미 실행 중인 경우 애플리케이션을 중지하는 방법, 코드 설치 방법, 코드 설치 전후에 실행할 명령 및 애플리케이션을 다시 실행하는 방법을 CodeDeploy에 알려줍니다.
      - 배포 그룹
        - 배포 그룹은 배포 대상 환경을 지정합니다. 포함되는 정보는 대상 컴퓨팅 플랫폼(AWS Lambda, Amazon ECS, Amazon EC2 또는 온프레미스)에 따라 다릅니다. 예를 들어 Amazon ECS를 사용하면 Amazon ECS 서비스, 로드 밸런서 등을 지정할 수 있습니다. Amazon EC2의 경우 배포 대상 인스턴스 또는 물리적 환경의 논리적 그룹입니다.
        - CodeDeploy 애플리케이션에는 하나 이상의 배포 그룹이 있을 수 있습니다.
        - 환경이 CodeDeploy와 통신할 수 있도록 보안 정보를 할당해야 합니다.
        - Amazon EC2 또는 온프레미스 컴퓨팅 플랫폼에 배포하는 경우 CodeDeploy 에이전트가 필요합니다. 대상 인스턴스에 설치 및 구성됩니다. CodeDeploy를 대신하여 요청을 수락하고 실행합니다.
      - 구성 배포
        - 배포 구성은 배포 규칙과 배포 성공 및 배포 실패 조건의 세트로, 배포 중에 AWS CodeDeploy에 사용됩니다. Amazon EC2 컴퓨팅 플랫폼의 경우, 배포 중에 계속 가용 상태로 유지되어야 하는 인스턴스의 수 또는 비율을 지정합니다. 또한 배포 그룹의 인스턴스를 잠시 오프라인으로 전환하여 최신 코드 개정 버전으로 업데이트할지 또는 새 인스턴스로 배포 그룹의 인스턴스를 대체할지를 지정합니다.
  - 추가 서비스
    - 통합 개발 환경(IDE) 서비스
      - IDE(통합 개발 환경)는 구문 강조 표시, 자동 완성, 구문 힌트 등의 기능을 통해 개발자의 생산성을 높입니다.
      - IDE는 로컬로 설치하거나 클라우드를 기반으로 할 수 있으며, 웹 브라우저에서 액세스할 수 있습니다.
        - AWS Cloud9는 Amazon의 클라우드 기반 IDE로, 브라우저만으로 코드를 작성, 실행 및 디버깅하는 데 사용할 수 있습니다. AWS Cloud9을 사용하여 CodeCommit 리포지토리에서 코드를 변경할 수 있습니다. AWS 전용 소프트웨어 개발 키트(SDK)에 AWS Cloud9를 사용할 수도 있습니다.
    - 인프라 관리 서비스
      - 인프라를 Infrastructure as Code(IaC)로 취급하면 팀의 민첩성과 효율성이 향상되고 인프라가 더욱 강력해지고 전반적인 비용이 절감됩니다.
      - IaC의 경우 인프라의 배포 및 업데이트가 일관되고 반복 가능하기 때문입니다.
        - AWS CloudFormation은 IaC 서비스입니다. 템플릿을 사용하면 필요한 리소스와 종속성을 설명할 수 있으므로, 수명 주기 전반에 걸쳐 신속하고 일관되게 프로비저닝 및 관리할 수 있습니다. 리소스를 개별적으로 관리하는 대신, 전체 스택을 단일 유닛으로 필요한 만큼 자주 생성, 업데이트, 삭제할 수 있습니다. 여러 AWS 계정 및 AWS 리전에서 스택을 관리하고 프로비저닝할 수 있습니다.
        - AWS OpsWorks는 구성 관리 서비스입니다. Chef 및 Puppet 자동화 플랫폼의 관리형 인스턴스를 제공하며, Amazon EC2 인스턴스 또는 온프레미스 컴퓨팅 환경에서 서버를 구성, 배포 및 관리하는 방식을 자동화할 수 있습니다.
    - 컨테이너 및 서버리스 서비스
      - AWS는 개발 작업을 지원하고 파이프라인을 개선하는 다양한 서비스를 제공합니다.
        - AWS Lambda는 코드를 작성하고 호출 시 실행할 수 있는 서버리스 컴퓨팅 서비스입니다. Lambda 함수를 사용하면 CI/CD 파이프라인을 사용자 지정할 수 있습니다. 예를 들어 릴리스 작업을 승인하고, 릴리스 흐름을 중단하고, 배포 시에 트래픽 흐름을 제어하는 등의 작업을 수행할 수 있습니다.
        - Amazon Elastic Container Service(Amazon ECS)는 Docker 컨테이너를 지원하는 확장성이 뛰어난 고성능 컨테이너 관리 서비스입니다. Amazon Elastic Compute Cloud(Amazon EC2) 인스턴스의 관리형 클러스터에서 애플리케이션을 손쉽게 실행할 수 있습니다. ECS를 사용하면 컨테이너 관리 소프트웨어를 설치, 운영 및 확장할 필요가 없습니다.
