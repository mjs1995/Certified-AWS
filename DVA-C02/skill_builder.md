# Amazon EKS Primer
- Amazon EKS Primer
  - Amazon Elastic Kubernetes Service
    - Amazon Elastic Kubernetes Service(Amazon EKS)는 AWS Cloud 또는 온프레미스에서 Kubernetes 애플리케이션의 배포, 관리 및 크기 조정을 용이하게 하는 관리형 컨테이너 오케스트레이션 서비스입니다.
    - Amazon EKS는 패치, 노드 프로비저닝 및 업데이트와 같은 주요 작업을 자동화하는 데도 도움을 줍니다.
  - 컨테이너 오케스트레이션의 필요성
    - 컨테이너는 애플리케이션의 코드, 구성 및 종속성을 하나의 객체로 패키징하는 표준화된 방식을 제공합니다.
    - 컨테이너는 가벼울 뿐만 아니라, 애플리케이션을 어디서나 실행하고 확장하기 위한 일관되고 이동 가능한 소프트웨어 환경을 제공합니다.
    - 컨테이너에 대해 잘 알려진 용례 가운데는 마이크로서비스 구축 및 배포, 배치 작업 실행, 머신러닝 애플리케이션 지원, 기존 애플리케이션을 클라우드로 이동하는 기능 등이 있습니다.
    - 컨테이너에서 실행하는 애플리케이션을 사용하려면 배치를 관리하고 확장하기 위한 컨테이너 오케스트레이션 플랫폼이 필요합니다.
  - 주요 카테고리
    - 컨테이너 스케줄링 및 배치
    - 컨테이너 수를 자동으로 적절하게 스케일 인 또는 스케일 아웃
    - 비정상 컨테이너를 자동으로 제거하고 그 위치에 새 컨테이너를 배포하여 서비스를 자가 치유
    - 네트워킹 서비스 및 영구 스토리지와 같은 클라우드 및 기타 서비스와의 통합
    - 시스템 보안, 모니터링 및 로깅
- Kubernetes
  - Kubernetes 객체
    - 클러스터
      - 컨테이너화된 애플리케이션을 실행하는 노드라는 일련의 작업자 머신입니다.
      - 모든 클러스터에는 하나 이상의 작업자 노드가 있습니다. 또한 클러스터에는 클러스터를 관리하는 서비스를 실행하는 제어 영역도 있습니다.
    - 노드
      - Kubernetes는 컨테이너를 포드에 그룹화하고 노드에서 실행할 이러한 포드를 할당함으로써 워크로드를 실행합니다.
      - 노드는 클러스터에 따라 가상이거나 물리적 머신일 수 있습니다. 각 노드는 제어 영역에서 관리되고 포드를 실행하는 데 필요한 서비스를 포함합니다.
    - 포드
      - 하나 이상의 컨테이너로 구성된 그룹입니다.
      - 포드는 컨테이너 실행 방법에 대한 사양인 PodSpec 파일에 의해 정의됩니다.
      - 포드는 배포, 크기 조정 및 복제를 위한 Kubernetes 내 기본 빌딩 블록입니다.
    - 볼륨
      - 휘발성 볼륨
        - 포드에 있는 애플리케이션은 공유 볼륨에 액세스하여 포드에서 데이터 공유 및 컨테이너 재시작 간 데이터의 지속성 유지를 용이하게 합니다.
        - 포드가 종료되면 Kubernetes는 휘발성 볼륨을 파괴합니다.
      - 영구 볼륨
        - 영구 볼륨은 휘발성 볼륨과 유사하게 기능하지만 수명 주기가 이를 사용하는 개별 포드와 무관합니다.
        - 영구 볼륨은 클러스터 노드와 상관 없이 스토리지 하위 시스템에서 지원됩니다.
    - 서비스
      - Kubernetes에서 서비스는 포드의 논리적 컬렉션이며 포드에 액세스하기 위한 수단입니다.
      - 서비스는 사용 가능한 포드 세트를 바탕으로 지속적으로 업데이트되어 포드가 다른 포드를 추적할 필요가 없습니다.
    - 네임스페이스
      - 동일한 물리적 클러스터에서 지원되는 가상 클러스터입니다.
      - 물리적 클러스터는 서로 다른 네임스페이스에 있다면 리소스가 동일한 이름을 가질 수 있습니다.
      - 특히 네임스페이스는 여러 팀이나 프로젝트가 동일한 클러스터를 사용할 때 유용합니다.
    - ReplicaSet
      - 언제든 주어진 시간에 특정 개수의 포드 복제본이 실행되도록 합니다.
    - 배포
      - ReplicaSet 또는 개별 포드를 소유하고 관리합니다.
      - 배포에서 원하는 상태를 설명합니다. 그런 다음 배포는 클러스터의 실제 상태를 제어된 비율의 원하는 상태로 변경합니다.
    - ConfigMap
      - ConfigMap은 포드와 같은 기타 Kubernetes 객체에서 사용하는 키-값 쌍으로 기밀 데이터 이외의 데이터를 저장하는 API 객체입니다.
      - ConfigMaps를 사용하여 구성 데이터를 애플리케이션 코드와 분리하여 이동성의 모범 실무를 따르십시오.
    - 보안 정보
      - AWS 자격 증명과 같은 모든 기밀 데이터는 Kubernetes 보안 정보로 저장되어야 합니다.
      - 보안 정보는 민감한 정보에 대한 액세스를 제한합니다.
      - 원한다면 암호화를 켜서 보안을 강화할 수도 있습니다.
  - 포드 예약
    - Kubernetes 스케줄러로 포드를 예약할 수 있습니다. 스케줄러는 포드에 필요한 리소스를 확인하고 그 정보를 사용하여 스케줄링 결정에 영향을 줍니다.
    - 스케줄러는 일련의 필터를 실행하여 포드 배치에 부적격한 노드를 제외시킵니다.
  - 사용자 지정 리소스
    - Kubernetes가 정의하는 리소스(포드 및 배포) 외에도, Kubernetes API를 확장하고 사용자 지정 리소스를 생성할 수 있습니다.
    - 사용자 지정 리소스는 서비스 메시 객체와 같은 새 객체일 수도 있고 기본 Kubernetes 리소스의 조합일 수도 있습니다. 사용자 지정 리소스는 CRD(Custom Resource Definition)를 사용하여 생성됩니다.
  - 사용자 지정 리소스
    - Kubernetes가 정의하는 리소스(포드 및 배포) 외에도, Kubernetes API를 확장하고 사용자 지정 리소스를 생성할 수 있습니다.
    - 사용자 지정 리소스는 서비스 메시 객체와 같은 새 객체일 수도 있고 기본 Kubernetes 리소스의 조합일 수도 있습니다.
    - 사용자 지정 리소스는 CRD(Custom Resource Definition)를 사용하여 생성됩니다.
- Amazon EKS 가용성 및 API
  - Amazon EKS 제어 영역은 3개의 가용 영역에 걸친 최소 2개의 API 서버 노드와 3개의 etcd 노드로 구성됩니다.
  - Amazon EKS는 비정상 제어 영역 노드를 자동으로 탐지하여 교체하므로 Kubernetes 실행에 따른 운영 부담이 대폭 제거됩니다.
  - 이 기능을 사용하면 AWS 인프라를 관리하는 대신 애플리케이션 빌드에 집중할 수 있습니다.
  - Amazon EKS로 데이터 영역을 관리하는 이유는 무엇입니까?
    - 작업자 노드가 많은 복잡한 인프라를 관리하고 오토스케일링과 업데이트를 신경쓰는 것은 쉽지 않습니다. 또한 클러스터에 노드를 프로비저닝하는 여러 팀이 있을 수 있으며, 이들의 프로비저닝 방식은 각각 다를 수 있습니다.
    - 이러한 차이로 인해 표준화가 어려워집니다. Amazon EKS가 데이터 영역의 일부 또는 전부를 관리할 수 있도록 하면 인프라를 간소화하고 표준화를 유지할 수 있습니다.
    - 자체 관리형 노드
      - 제어 영역만 Amazon EKS에서 관리합니다. 데이터 영역 노드(프로비저닝, 업데이트, 모니터링 및 기타 작업)를 완벽하게 제어하고 관리할 수 있습니다.
    - 관리형 노드 그룹
      - 관리형 노드 그룹은 Amazon EKS API를 사용하여 Amazon EKS 클러스터용 컨테이너를 실행하는 Amazon Elastic Cloud Computing(Amazon EC2) 인스턴스를 시작하고 관리합니다. 관리형 노드 그룹은 자동으로 시작되고 관리되지만 EC2 인스턴스 및 Auto Scaling 그룹과 같이 AWS 계정에서 사용 중인 모든 리소스를 계속 볼 수 있습니다. 더 적은 작업으로 제어, 보안, 가시성을 모두 확보할 수 있습니다.
      - 프로비저닝
        - 관리형 노드 그룹을 단일 명령으로 배포합니다. 그러면 Amazon EKS가 최신 Amazon EKS 최적화 AMI(Amazon Machine Images)를 사용하여 노드를 생성합니다.
        - AWS 서비스는 이를 여러 가용 영역에 배포하고 Auto Scaling 그룹으로 지원합니다. 크기 조정 파라미터를 변경할 수 있습니다.
      - 관리
        - Amazon EKS는 관리형 노드 그룹의 상태 모니터링을 처리합니다.
        - Amazon EKS는 삭제 중이거나 연결할 수 없거나 사용할 수 없는 필수 리소스를 포함한 문제를 사용자에게 자동으로 알려줍니다.
        - Amazon EKS는 업데이트 문제, 한도 초과, 생성 또는 삭제 실패에 대해서도 알려줍니다. 노드 수준 Secure Shell(SSH) 액세스, 오픈 소스 로그 라우터 또는 Amazon CloudWatch에서 로그를 가져올 수도 있습니다. 또한 모든 관리형 노드 그룹 이벤트는 AWS CloudTrail에 기록됩니다.
      - 업데이트
        - 필요한 경우 단일 명령으로 관리형 노드 그룹을 업데이트할 수 있습니다. 그러면 Amazon EKS는 롤링 업데이트 시 노드 종료를 처리하고 Kubernetes 버전에 맞는 최신 AMI 버전으로 자동 업데이트합니다.
      - 크기 조정
        - 관리형 노드 그룹이 노드의 크기 조정을 처리합니다. 하지만 Kubernetes 레이블, AWS 태그, 노드 그룹의 크기와 같은 크기 조정 파라미터는 사용자가 여전히 제어할 수 있습니다.
      - 도구
        - eksctl을 사용하여 관리형 노드 그룹을 프로비저닝할 수 있습니다.
    - AWS FARGATE
      - 관리형 노드 그룹을 사용하면 인프라 관리에 쓰는 시간이 줄어듭니다. 하지만 애플리케이션 생성에만 집중하고 Amazon EKS가 데이터 영역을 완전히 관리하도록 하는 것이 좋습니다. 이는 Fargate에서 포드를 실행하면 가능합니다.
      - Fargate는 Kubernetes 데이터 영역의 전체 인프라를 관리합니다. 포드를 실행하는 데만 신경 쓰면 됩니다.
        - 네이티브 - Fargate는 네이티브 Kubernetes 포드를 실행합니다. AWS와 관련하여 아무것도 구성하거나 변경할 필요가 없습니다.
        - 적정 규모 – Fargate는 포드와 리소스에 필요한 리소스만 동적으로 프로비저닝합니다.
        - 빠르고 간편함 – Fargate는 신속하게 크기를 조정합니다. Cluster Autoscaler를 설치할 필요가 없습니다.
        - 최적화 – 포드가 실행될 때만 포드 비용을 지불하고, 포드 수준 청구를 확인할 수 있습니다.
- AWS EKS 구성
  - Amazon EKS에서 인증 및 권한 부여
    - AWS API 사용
      - aws eks create-cluster와 같은 AWS 명령의 경우에는 AWS IAM 서비스가 인증과 권한 부여를 모두 처리합니다.
      - Amazon EKS는 이에 따라 다른 AWS 서비스처럼 행동합니다.
    - KUBERNETES API 사용
      - kubectl get nodes와 같은 Kubernetes 명령의 경우 Amazon EKS는 Kubernetes 클러스터에 IAM 사용자 인증을 사용하지만, 권한 부여에는 기본 Kubernetes RBAC에 의존합니다. 인증을 위해 IAM 서비스를 사용하면 두 가지 기본적인 방식에서 클러스터 사용자 관리가 간소화됩니다.
        - IAM과 Amazon EKS 모두 AWS에서 관리하는 통합 서비스입니다.
        - 최종 사용자 인증을 제공하지 않는 Kubernetes의 문제를 해결합니다.
      - Amazon EKS 클러스터의 Kubernetes API와 상호 작용하기 위한 모든 권한은 기본 Kubernetes RBAC 시스템을 통해 관리됩니다.
  - 권한 구성
    - 클러스터 IAM 역할
      - Amazon EKS에서 클러스터를 관리하기 위해 사용자를 대신하여 AWS API를 호출할 수 있는 권한이 필요합니다.
      - 예를 들어 Amazon EKS에는 작업자 노드용 EC2 Auto Scaling을 관리할 권한이 필요합니다. 이 권한은 클러스터에 할당된 IAM 역할에 의해 제어됩니다. AWS는 IAM 정책에 이 역할에 대한 권장 권한을 제공합니다.
    - 노드 IAM 역할
      - Amazon EKS 작업자 노드의 kubelet 데몬은 사용자를 대신하여 AWS API를 호출합니다(예: Amazon Elastic Container Registry(Amazon ECR)에서 컨테이너 이미지 가져오기).
      - 작업자 노드는 작업자 노드에 할당된 IAM을 통해 이러한 API 호출에 대한 권한을 받습니다.
    - RBAC 사용자
      - Kubernetes 클러스터를 관리할 관리자는 Kubernetes API를 호출할 권한이 필요합니다. 이는 IAM 역할을 Kubernetes RBAC 사용자에게 매핑하여 이루어집니다. 클러스터를 생성하는 데 사용되는 IAM 역할에는 클러스터를 관리할 수 있는 전체 권한이 있으며, 일반적으로 필요한 것보다 더 많은 권한입니다.
      - 모범 실무는 클러스터 배포만을 위한 특정 IAM 역할을 생성하는 것입니다. 최소 권한의 원칙에 따라, IAM의 일상적인 운영을 위해 RBAC에서 더 제한적인 역할에 매핑하는 추가 원칙을 생성하십시오.
  - Amazon EKS 클러스터용 VPC는 세 가지 일반적인 설계 패턴 중 하나를 사용할 수 있습니다.
    - 퍼블릭 서브넷만
      - 이 VPC에는 리전의 다른 가용 영역에 배포되는 3개의 퍼블릭 서브넷이 있습니다.
      - 모든 작업자 노드에는 퍼블릭 IP 주소가 자동으로 할당되며 인터넷 게이트웨이를 통해 인터넷 트래픽을 주고받을 수 있습니다.
      - 모든 인바운드 트래픽을 거부하고 모든 아웃바운드 트래픽을 허용하는 보안 그룹이 배포됩니다.
    - 프라이빗 서브넷만
      - 이 VPC에는 리전의 다른 가용 영역에 배포되는 최대 3개의 퍼블릭 서브넷이 있습니다.
      - 모든 노드는 선택적으로 NAT(네트워크 주소 변환) 인스턴스 또는 NAT 게이트웨이를 통해 인터넷 트래픽을 보내고 받을 수 있습니다.
      - 모든 인바운드 트래픽을 거부하고 모든 아웃바운드 트래픽을 허용하는 보안 그룹이 배포됩니다.
    - 퍼블릭 및 프라이빗 서브넷
  - eksctl이 수행하는 작업의 개요
    - 클러스터 및 작업자 노드의 IAM 역할 생성
    - CIDR(클래스 없는 도메인 간 라우팅) 192.168.0.0/16을 사용하여 전용 VPC 생성
    - 클러스터 및 노드 그룹 생성
    - API 엔드포인트에 대한 액세스 구성
    - CoreDNS 설치
    - 클러스터의 kubeconfig 파일 작성
  - 수평 및 수직적 크기 조정
    - 수평적 크기 조정 : 수평으로 확장 가능한 시스템이란 컴퓨팅 리소스를 추가하거나 제거하여 용량을 늘리거나 줄일 수 있는 시스템입니다. 이 예에서는 수요가 급등할 때 더 많은 포드가 배포됩니다(스케일 아웃). 수요가 감소하면 포드가 제거됩니다(스케일 인).
    - 수직적 크기 조정 : 수직으로 확장 가능한 시스템은 더욱 빠른(또는 더욱 많은) CPU, 메모리 또는 스토리지와 같은 리소스를 컴퓨팅 리소스에 추가하여 성능을 높입니다.이 예에서는 수요가 급등할 때 포드의 크기(할당된 CPU 및 메모리 리소스)가 증가하고(스케일 업) 수요가 감소하면 크기가 줄어듭니다(스케일 다운).
  - 오토스케일링
    - Karpenter: Cluster Autoscaler의 대안
      - Karpenter는 노드 수명 주기 관리 솔루션입니다. 들어오는 포드를 관찰하고 상황에 적합한 인스턴스를 시작합니다.
      - 인스턴스 선택 결정은 의도 기반이며 리소스 요청 및 스케줄링 제약 조건을 비롯한 수신 포드 사양에 구속됩니다.
      - Karpenter가 배포되면
        - 예약되지 않은 포드에 대한 노드를 시작합니다.
        - 기존 노드를 대체하여 리소스 활용도를 높입니다.
        - 오래되었거나 더 이상 필요하지 않은 노드는 종료합니다.
        - 선점하기 전에 정상적으로 노드를 드레이닝합니다.
    - Horizontal Pod Autoscaler
      - Horizontal Pod Autoscaler(HPA)는 CPU 사용률 또는 Kubernetes 지표 서버를 통해 정의한 기타 지표를 기준으로 서비스를 자동으로 스케일 인 하거나 스케일 아웃 하는 Kubernetes 구성 요소입니다.
    - Kubernetes Vertical Pod Autoscaler(VPA)
      - 포드에 예약된 CPU 및 메모리를 자동으로 조정하여 애플리케이션의 크기를 적절히 조정할 수 있게 지원합니다. 이를 통해 클러스터 리소스 사용률을 개선하고 다른 포드를 위한 CPU 및 메모리를 확보할 수 있습니다.
  - EKS 통신 유형
    - Amazon EKS 환경에는 여러 통신 유형이 있습니다. 다음과 같은 통신 라인들이 있습니다.
    - 컨테이너 사이 포드 간 통신
      - 포드의 컨테이너는 Linux 네임스페이스를 공유하며 localhost로 서로 통신할 수 있습니다.
      - Kubernetes 네트워킹에서 컨테이너가 식별하는 IP 주소는 네트워크의 모든 엔터티에 대한 IP 주소와 동일합니다. 모든 컨테이너는 NAT 없이도 포드 내의 다른 모든 컨테이너와 통신할 수 있습니다.
    - 동일한 노드의 포드 간 또는 서로 다른 노드의 포드 간 통신
      - 각 포드에는 Linux 네임스페이스가 있지만 호스트 노드에도 Linux 네임스페이스가 있습니다. 각 네임스페이스에는 고유한 라우팅 테이블이 존재합니다.
      - 포드 네임스페이스와 호스트 네임스페이스는 Linux 가상 이더넷(veth) 디바이스를 이용해 연결됩니다. veth 한 쌍이 기본 호스트 네임스페이스와 Pod 네임스페이스 간에 터널을 만듭니다.
      - 호스트의 포드 간 통신은 이 veth 터널을 통해 발생합니다. 각 노드에 컨테이너의 네트워크 범위가 할당되고 각 포드는 동일한 호스트에 있는 컨테이너들이 통신할 수 있도록 해당 범위의 IP 주소를 가져옵니다.
    - 클러스터 외부에서의 인그레스 연결
      - 노드 간 통신을 간소화하기 위해 Amazon EKS는 Kubernetes용 Amazon VPC CNI 플러그 인을 통해 Amazon VPC 네트워킹을 Kubernetes에 통합합니다. CNI를 사용하면 Kubernetes 포드는 VPC 네트워크에서처럼 해당 포드 내에서 동일한 IP 주소를 가질 수 있습니다.
  - 수신(Ingress)
    - Kubernetes 수신 객체를 사용하면 사용하는 로드 밸런서의 수를 줄일 수 있습니다. 수신 객체는 클러스터 외부에 있는 HTTP 및 HTTPS 경로를 서비스에 노출하고 트래픽 규칙을 정의합니다.
  - AWS Load Balancer Controller
    - AWS Load Balancer Controller는 Kubernetes 클러스터용 ELB(Elastic Load Balancer(Elastic Load Balancing)를 관리하는 컨트롤러입니다.
    - 로드 밸런서는 Kubernetes 수신을 생성하는 경우 Application Load Balancer이거나 LoadBalancer 유형의 Kubernetes 서비스를 생성하는 경우 Network Load Balancer일 수 있습니다.
    - Application Load Balancer는 Open Systems Interconnection(OSI) 모델의 계층 7(예: HTTP 또는 HTTPS)에서의 애플리케이션 트래픽을 밸런싱하는 반면,
    - Network Load Balancer는 계층 4[예: Transmission Control Protocol(TCP), User Datagram Protocol(UDP) 등]에서의 네트워크 트래픽을 밸런싱합니다.
    - Application Load Balancer는 노드 또는 Fargate에 배포된 포드와 함께 사용될 수 있습니다.
    - Application Load Balancer는 퍼블릭 또는 프라이빗 서브넷에 배포될 수 있습니다.
    - Network Load Balancer는 Amazon EC2 IP및 인스턴스 대상에 배포된 포드나 Fargate IP 대상에 네트워크 트래픽을 로드 밸런싱할 수 있습니다.
- EKS 다른 서비스와 통합
  - Kubernetes 영구 스토리지
    - 포드 수명 주기와 상관 없이 데이터 지속성이 필요한 애플리케이션 워크로드에는 두 가지 이상의 Kubernetes 객체와 영구 볼륨(PV) 및 영구 볼륨 클레임(PVC)이 필요합니다.
    - PV는 임시 볼륨이지만 개별 포드에 독립적인 수명 주기를 가진다는 점을 상기시킵니다.
    - PVC는 클러스터 사용자에 의한 스토리지에 대한 요청으로, 요청에 스토리지 양, 스토리지 액세스 종류 및 스토리지 성능에 대한 세부정보가 포함됩니다.
  - AMAZON EBS 사용
    - 클러스터 사용자가 필수 파라미터와 함께 PVC를 제출할 때 Amazon EBS 스토리지 클래스가 EBS CSI 드라이버에서 호출되어 PVC 요청당 스토리지를 할당합니다.
    - EBS CSI 드라이버는 EBS 볼륨을 생성하고 볼륨을 지정된 클러스터 노드에 연결하는 데 필요한 AWS API를 호출합니다. 연결되면 영구 볼륨이 PVC에 할당됩니다.
    - Amazon EBS CSI 드라이버를 구성하여 볼륨 크기 조정, 볼륨 스냅샷 생성 등을 포함한 여러 가지 Amazon EBS 기능을 사용할 수 있습니다.
  - AMAZON EFS 사용
    - Amazon EFS에서 지원하는 Kubernetes 스토리지 클래스는 Amazon EFS CSI 드라이버에 기존 파일 시스템에 대한 액세스 포인트를 생성하기 위한 적절한 AWS API를 호출할 것을 지시합니다.
    - PVC가 생성되면 동적으로 프로비저닝된 PV가 Amazon EFS 파일 시스템에 액세스하는 데 해당 액세스 포인트를 사용한 다음 PVC로 바인딩됩니다.
  - AWS App Mesh
    - App Mesh는 서비스 모니터링 및 제어를 일련화하는 서비스입니다.
    - App Mesh는 서비스의 통신 방식을 표준화하여 사용자에게 엔드 투 엔드 가시성을 제공하고 애플리케이션에 대한 고가용성을 보장합니다.
    - App Mesh는 애플리케이션의 모든 서비스에 일관된 가시성 및 네트워크 트래픽 제어 기능을 제공합니다.
- Amazon EKS 클러스터 업그레이드
  - 새 Kubernetes 버전으로 업그레이드할지 여부를 결정할 때 다음 사항을 고려하십시오.
    - Kubernetes의 다음 버전으로 업그레이드할 때 이점은 무엇입니까?
    - Kubernetes 버전의 업그레이드 완료를 어느 팀에서 담당합니까?
    - 노드 및 추가 기능과 같은 다운스트림 구성 요소 중에서 함께 업그레이드해야 하는 것은 무엇입니까?
    - 다운스트림 종속성을 어떤 순서로 업그레이드해야 합니까?
    - 업그레이드가 진행되는 동안 애플리케이션에 어떤 영향을 줍니까?
    - 에코시스템 내 애플리케이션 중 Kubernetes API를 사용하는 것이 있습니까? 이 애플리케이션에 대한 영향 분석을 수행하는 것도 고려해봅니다.
- Amazon EKS 업그레이드 프로세스
  - 클러스터 업그레이드 중 발생하는 이벤트 순서
    - API 서버 노드
      - 업그레이드 시 Amazon EKS는 업그레이드된 Kubernetes 버전으로 새 API 서버 노드를 시작하여 기존 노드를 대체합니다.
      - Amazon EKS는 이러한 새 노드의 네트워크 트래픽에 대한 표준 인프라 및 준비 상태 확인을 수행하여 예상대로 작동하는지 확인합니다.
    - 자동 롤백
      - 이러한 검사 중 하나라도 실패할 경우 Amazon EKS가 인프라 배포를 되돌리고, 클러스터는 이전 Kubernetes 버전으로 남아 있게 됩니다.
      - 실행 중인 애플리케이션은 영향을 받지 않으며 클러스터는 복구할 수 없는 상태로 남아 있지 않습니다. Amazon EKS는 모든 관리형 클러스터를 정기적으로 백업하며 필요한 경우 클러스터를 복구하는 메커니즘이 존재합니다.
    - 경미한 서비스 중단 발생 가능
      - 클러스터를 업그레이드하기 위해 Amazon EKS는 클러스터를 생성할 때 제공된 서브넷에 사용 가능한 IP 주소 2~3개가 필요합니다. 이 서브넷에 사용 가능한 IP 주소가 없으면 업그레이드가 실패할 수 있습니다.
      - 클러스터 생성 시 제공된 서브넷 또는 보안 그룹이 삭제된 경우, 클러스터 업그레이드 프로세스가 실패할 수 있습니다.
    - 노드 및 Kubernetes 추가 기능 업그레이드
      - Amazon EKS는 클러스터의 제어 영역을 업그레이드할 때 실행 중인 애플리케이션, 클러스터 작업자 노드, Amazon EKS 추가 기능 또는 Kubernetes 추가 기능을 수정하지 않습니다.
      - 클러스터 업그레이드 프로세스를 완료하는 데 필요한 작업을 수행해야 합니다.
  - Amazon EKS는 관리형 노드 그룹 버전을 업그레이드할 때 다음 작업을 수행합니다.
    - Amazon EKS는 사용자의 노드 그룹과 연결된 EC2 Auto Scaling 그룹을 위한 새로운 Amazon EC2 시작 템플릿 버전을 생성합니다. 이 신규 템플릿은 업데이트를 위해 대상 AMI를 사용합니다.
    - 새 AMI에 최신 시작 템플릿을 사용하도록 EC2 Auto Scaling 그룹이 업그레이드됩니다.
    - 기존 EC2 인스턴스와 함께 새 EC2 인스턴스가 생성되도록 EC2 Auto Scaling 그룹의 최대 크기와 원하는 크기가 증분됩니다.
    - EC2 Auto Scaling 그룹이 더 커진 노드 그룹의 크기를 충족하기 위해 새 AMI로 새 인스턴스를 시작합니다.
    - Amazon EKS가 노드 그룹 내 노드들의 eks.amazonaws.com/nodegroup-image 레이블을 점검합니다. Amazon EKS는 노드 그룹에서 최신 AMI ID로 레이블이 지정되지 않은 모든 노드를 코든합니다. 이렇게 하면 이전에 실패한 업그레이드에서 이미 업그레이드된 노드가 코든되지 않습니다.
    - Amazon EKS가 노드 그룹에서 노드를 임의로 선택하고 EC2 Auto Scaling 그룹에 종료 신호를 보냅니다. 그다음 Amazon EKS는 노드에서 포드를 드레인하라는 신호를 보냅니다. 노드가 드레인되면 종료됩니다. 모든 노드가 새 AMI 버전을 사용할 때까지 이 절차가 반복됩니다.
    - EC2 Auto Scaling 그룹의 최대 크기와 원하는 크기가 1씩 감소하여 업그레이드 이전의 값으로 돌아갑니다.
    - 업데이트 전략의 두가지 옵션
      - 롤링 업데이트 – 이 옵션은 클러스터에 대한 PodDisruptionBudget에 따릅니다. PodDisruptionBudget 문제 때문에 Amazon EKS가 이 노드 그룹에서 실행되고 있는 Pod를 정상적으로 드레인할 수 없는 경우, 업데이트가 실패합니다.
      - 강제 업데이트 – 이 옵션은 PodDisruptionBudgets를 준수하지 않습니다. 노드를 강제로 다시 시작합니다.
  - 자체 관리형 작업자 노드
    - 자체 관리형 노드 그룹을 업그레이드하고 있다면 두 가지 전략을 고려할 수 있습니다.
      - 새 노드 그룹으로 마이그레이션 – 새 노드 그룹을 생성하고 포드를 해당 그룹으로 마이그레이션합니다.
      - 기존 자체 관리형 노드 그룹업데이트 – 기존 노드 그룹에 대한 CloudFormation 스택을 업데이트하여 새 AMI를 사용합니다.

# Getting Started with DevOps on AWS
- DevOps
  - DevOps란?
    - DevOps는 애플리케이션과 서비스를 빠른 속도로 제공할 수 있도록 조직의 역량을 향상시키는 문화 철학, 방식 및 도구의 조합입니다.
    - 기존의 소프트웨어 개발 및 인프라 관리 프로세스를 사용하는 조직보다 제품을 더 빠르게 혁신하고 개선할 수 있습니다.
    - 장벽을 제거하고 포괄적인 책임 공유 실현하기 위한 문화적 철학
    - 높은 속도와 품질로 사람들이 작업하는 방식을 간소화하도록 개발된 프로세스
    - 프로세스에 맞게 조정하고 반복 가능한 태스크를 자동화하여 릴리스 프로세스의 효율성과 애플리케이션의 안정성을 높이는 도구
  - 기존 개발 방식의 문제점
    - 폭포형 개발 프로젝트는 느리고 반복이 불가능하며 변화를 수용하기가 어렵고 릴리스 주기가 깁니다.
      - 몇 가지 이유
        - 요구 사항이 엄격하고 프로젝트 시작 시 설정되며 변경되지 않습니다.
        - 개발 단계가 사일로화되어 있으며, 각 단계는 이전 단계가 끝난 후 시작됩니다. 각 단계는 고도로 전문화된 팀이 지원합니다. 한 단계에서 다른 단계로 넘기는 시간이 길기 때문에 팀이 도구를 전환하고 불완전하거나 모호한 정보를 명확히 하는 데 시간을 할애해야 하는 경우가 많습니다.
        - 테스트 및 보안은 구현 후에 이루어지고, 시정 조치는 사후 대응적이고 비용이 많이 듭니다.
