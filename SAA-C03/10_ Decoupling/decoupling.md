# AWS Integration & Messaging
- 여러 애플리케이션을 배포하기 시작하면, 이들은 필연적으로 서로 통신해야 합니다.
- 애플리케이션 간의 통신에는 두 가지 패턴이 있습니다.
  - 동기 통신 (애플리케이션 간)
  - 비동기 / 이벤트 기반 통신 (애플리케이션 - 큐 - 애플리케이션)
- SQS: 큐 모델을 사용하여 분리
- SNS: 발행/구독 모델을 사용하여 분리
- Kinesis: 실시간 스트리밍 모델을 사용하여 분리
- 이러한 서비스는 우리의 애플리케이션과 독립적으로 확장할 수 있습니다!
- Amazon SQS 
  - 표준 대기열
    - 10년 이상의 역사를 가진 최초의 오퍼링
    - 완전히 관리되는 서비스로, 애플리케이션을 분리하는 데 사용됩니다.
    - 속성
      - 무제한 처리량, 대기열에 있는 메시지의 수도 무제한
      - 메시지의 기본 유지 보존 기간: 4일, 최대 14일
      - 낮은 대기 시간 (<10ms의 게시 및 수신)
      - 전송되는 메시지 당 256KB의 제한
    - 중복 메시지가 발생할 수 있음 (적어도 한 번의 전달, 가끔 발생)
    - 순서가 바뀐 메시지가 발생할 수 있음 (최선의 순서 보장)
  - 메시지 생성
    - SDK를 사용하여 SQS에 메시지를 생성합니다 (SendMessage API).
    - 메시지는 소비자가 삭제할 때까지 SQS에 유지됩니다.
    - 메시지 보존 기간: 기본값은 4일이며, 최대 14일까지 설정할 수 있습니다.
    - 예시: 처리할 주문을 전송합니다.
      - 주문 ID
      - 고객 ID
      - 원하는 모든 속성
    - SQS 표준: 무제한 처리량
  - 메시지 소비
    - 소비자 (EC2 인스턴스, 서버 또는 AWS Lambda에서 실행)...
    - 메시지를 가져오기 위해 SQS를 폴링합니다 (한 번에 최대 10개의 메시지 수신).
    - 메시지를 처리합니다 (예: 메시지를 RDS 데이터베이스에 삽입).
    - DeleteMessage API를 사용하여 메시지를 삭제합니다.
  - 다중 EC2 인스턴스 소비자
    - 소비자는 메시지를 병렬로 수신하고 처리합니다.
    - 적어도 한 번의 전달 보장
    - 가능한한 순서대로 메시지 처리
    - 소비자는 메시지를 처리한 후에 삭제합니다.
    - 처리 처리량을 향상시키기 위해 소비자를 수평으로 확장할 수 있습니다.
  - 보안
    - 암호화
      - HTTPS API를 통한 전송 중 암호화
      - KMS 키를 사용한 정지 중 암호화
      - 클라이언트가 직접 암호화/복호화를 수행하려는 경우 클라이언트 측 암호화
    - 액세스 제어: IAM 정책을 사용하여 SQS API에 대한 액세스 제어
    - SQS 액세스 정책 (S3 버킷 정책과 유사)
      - SQS 대기열에 대한 계정 간 액세스에 유용
      - 다른 서비스 (SNS, S3 등)가 SQS 대기열에 쓸 수 있도록 허용하는 데 유용
  - 가시성 시간 초과 
    - 메시지가 소비자에게 폴링되면 다른 소비자에게는 보이지 않게됩니다.
    - 기본적으로 "메시지 가시성 제한 시간"은 30초입니다.
    - 즉, 메시지를 처리하기 위해 30초의 시간이 주어집니다.
    - 메시지 가시성 제한 시간이 지나면 메시지는 SQS에서 "가시" 상태가 됩니다.
    - 메시지가 가시성 제한 시간 내에 처리되지 않으면 메시지가 두 번 처리될 수 있습니다.
    - 소비자는 ChangeMessageVisibility API를 호출하여 더 많은 시간을 얻을 수 있습니다.
    - 가시성 제한 시간이 높은 경우(시간 단위), 소비자가 중단되면 재처리에 시간이 소요될 수 있습니다.
    - 가시성 제한 시간이 너무 낮은 경우(초 단위), 중복 메시지가 발생할 수 있습니다.
  - Long Polling
    - 소비자가 큐에서 메시지를 요청할 때, 큐에 메시지가 없다면 메시지가 도착할 때까지 "대기"할 수 있습니다.이를 Long Polling이라고 합니다.
    - Long Polling은 SQS로의 API 호출 수를 줄이고 응용 프로그램의 효율성을 높이며 대기 시간을 줄입니다.
    - 대기 시간은 1초부터 20초까지 설정할 수 있으며 (20초가 좋습니다.)
    - Long Polling은 Short Polling보다 선호됩니다.
    - Long Polling은 큐 수준이나 WaitTimeSeconds를 사용하여 API 수준에서 활성화할 수 있습니다.
  - FIFO 큐
    - FIFO = 선입선출 (큐 내의 메시지 순서)
    - 제한된 처리량: 배치 없이 1초당 300개의 메시지, 배치 사용 시 1초당 3000개의 메시지
    - 중복 제거를 통한 정확히 한 번만 전송 가능
    - 메시지는 소비자에 의해 순서대로 처리됩니다.
- Amazon SNS
  - "이벤트 생성자"는 하나의 SNS 토픽으로만 메시지를 보냅니다.
  - 우리가 원하는 만큼 많은 "이벤트 수신자" (구독)가 SNS 토픽 알림을 수신하기 위해 있을 수 있습니다.
  - 토픽에 대한 각 구독자는 모든 메시지를 받습니다 (참고: 메시지 필터링을 위한 새로운 기능).
  - 토픽당 최대 12,500,000개의 구독 가능
  - 토픽 수는 최대 100,000개로 제한됩니다.
  - 게시 방법
    - 토픽 게시 (SDK 사용)
      - 토픽 생성
      - 구독 생성 (하나 이상)
      - 토픽에 발행
    - 직접 게시 (모바일 앱 SDK용)
      - 플랫폼 애플리케이션 생성
      - 플랫폼 엔드포인트 생성
      - 플랫폼 엔드포인트에 발행
      - Google GCM, Apple APNS, Amazon ADM과 호환됩니다.
  - 보안
    - 암호화
      - 전송 중에 HTTPS API를 사용한 암호화
      - 정지 상태에서의 암호화는 KMS 키를 사용
      - 클라이언트가 직접 암호화/복호화를 수행하려는 경우 클라이언트 측 암호화
    - 접근 제어: IAM 정책을 사용하여 SNS API에 대한 접근을 규제
    - SNS 액세스 정책 (S3 버킷 정책과 유사)
      - SNS 토픽에 대한 교차 계정 액세스에 유용
      - 다른 서비스 (S3 등)가 SNS 토픽에 작성할 수 있도록 허용하기에 유용합니다.
  - SNS + SQS: Fan Out (팬아웃)
    - SNS에서 한 번 푸시하면 구독하는 모든 SQS 큐에서 메시지를 수신합니다.
    - 완전히 디커플링되어 데이터 손실이 없습니다.
    - SQS는 데이터 지속성, 지연 처리 및 작업 재시도를 지원합니다.
    - 시간이 지나면 SQS 구독자를 추가할 수 있습니다.
    - SQS 큐의 액세스 정책이 SNS에서 쓰기를 허용하도록 해야 합니다.
    - 교차 리전 전달: 다른 리전의 SQS 큐와 함께 작동합니다.
  - 애플리케이션: S3 이벤트를 여러 개의 큐로 전송
    - 동일한 조합인 이벤트 유형(예: 객체 생성)과 접두사(예: images/)에 대해서는 하나의 S3 이벤트 규칙만 설정할 수 있습니다.
    - 동일한 S3 이벤트를 여러 개의 SQS 큐로 전송하려면 팬아웃을 사용하세요.
  - FIFO Topic
    - SQS FIFO와 유사한 기능
      - 메시지 그룹 ID에 따른 순서 지정 (동일 그룹의 모든 메시지는 순서대로 처리됨)
      - 중복 제거를 위해 중복 ID 또는 내용 기반 중복 제거 사용
    - SQS FIFO 큐만이 구독자로 설정 가능
    - 제한된 처리량 (SQS FIFO와 동일한 처리량)
  - 메시지 필터링
    - SNS 주제의 구독으로 전송되는 메시지를 필터링하기 위해 JSON 정책 사용
    - 구독에 필터 정책이 없는 경우 모든 메시지를 수신합니다.
- Kinesis
  - 실시간 스트리밍 데이터 수집, 처리 및 분석을 쉽게 할 수 있습니다.
  - 애플리케이션 로그, 메트릭, 웹사이트 클릭스트림, IoT 텔레메트리 데이터 등의 실시간 데이터를 수집합니다.
  - Kinesis Data Streams: 데이터 스트림을 캡처, 처리 및 저장합니다.
    - 데이터 보존 기간은 1일부터 365일까지 설정할 수 있습니다.
    - 데이터를 재처리(재생)할 수 있는 기능이 있습니다.
    - Kinesis에 데이터가 삽입되면 삭제할 수 없습니다(불변성).
    - 동일한 파티션을 공유하는 데이터는 동일한 샤드로 이동합니다(순서 보장).
    - 프로듀서: AWS SDK, Kinesis Producer Library (KPL), Kinesis Agent
    - 컨슈머
      - 직접 작성: Kinesis Client Library (KCL), AWS SDK
      - 관리형: AWS Lambda, Kinesis Data Firehose, Kinesis Data Analytics
    - Capacity Modes
      - 프로비저닝된 모드
        - 프로비저닝된 샤드 수를 선택하고 수동으로 또는 API를 사용하여 확장합니다.
        - 각 샤드는 1MB/s(또는 초당 1000개의 레코드)를 입력받습니다.
        - 각 샤드는 2MB/s를 출력받습니다(클래식 또는 향상된 팬아웃 컨슈머).
        - 시간당 프로비저닝된 샤드 단위로 비용을 지불합니다.
      - 온디맨드 모드
        - 용량을 프로비저닝하거나 관리할 필요가 없습니다.
        - 기본 용량이 자동으로 프로비저닝됩니다(1초당 4MB/s 또는 4000개의 레코드).
        - 지난 30일간의 최대 처리량을 기반으로 자동으로 확장됩니다.
        - 스트림당 시간당 및 데이터 입출력 단위로 비용을 지불합니다.
    - 보안
      - IAM 정책을 사용하여 액세스 및 권한을 제어합니다.
      - HTTPS 엔드포인트를 사용하여 전송 중 데이터 암호화합니다.
      - KMS를 사용하여 데이터 저장 중 암호화합니다.
      - 클라이언트 측에서 데이터의 암호화/복호화를 구현할 수 있습니다(더 어렵습니다).
      - VPC 내에서 액세스하기 위해 Kinesis에 대한 VPC 엔드포인트를 사용할 수 있습니다.
      - CloudTrail을 사용하여 API 호출을 모니터링할 수 있습니다.
  - Kinesis Data Firehose: 데이터 스트림을 AWS 데이터 저장소에 로드합니다.
  - Kinesis Data Analytics: SQL 또는 Apache Flink를 사용하여 데이터 스트림을 분석합니다.
  - Kinesis Video Streams: 비디오 스트림을 캡처, 처리 및 저장합니다.
